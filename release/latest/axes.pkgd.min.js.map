{"version":3,"file":"axes.pkgd.min.js","sources":["../src/Coordinate.ts","../src/browser.ts","../src/utils.ts","../src/const.ts","../src/AnimationManager.ts","../src/inputType/InputType.ts","../src/inputType/PanInput.ts","../src/EventManager.ts","../src/InterruptManager.ts","../src/AxisManager.ts","../src/eventInput/EventInput.ts","../src/eventInput/MouseEventInput.ts","../src/eventInput/TouchEventInput.ts","../src/eventInput/PointerEventInput.ts","../src/eventInput/TouchMouseEventInput.ts","../src/InputObserver.ts","../src/Axes.ts","../src/inputType/RotatePanInput.ts","../src/inputType/PinchInput.ts","../src/inputType/WheelInput.ts","../src/inputType/MoveKeyInput.ts","../src/index.umd.ts"],"sourcesContent":["export const getInsidePosition = (\n  destPos: number,\n  range: number[],\n  circular: boolean[],\n  bounce?: number[]\n): number => {\n  let toDestPos: number = destPos;\n  const targetRange: number[] = [\n    circular[0] ? range[0] : bounce ? range[0] - bounce[0] : range[0],\n    circular[1] ? range[1] : bounce ? range[1] + bounce[1] : range[1],\n  ];\n\n  toDestPos = Math.max(targetRange[0], toDestPos);\n  toDestPos = Math.min(targetRange[1], toDestPos);\n\n  return toDestPos;\n};\n\n// determine outside\nexport const isOutside = (pos: number, range: number[]): boolean => {\n  return pos < range[0] || pos > range[1];\n};\n\n// determine whether position has reached the maximum moveable area\nexport const isEndofBounce = (\n  pos: number,\n  range: number[],\n  bounce: number[],\n  circular: boolean[]\n): boolean => {\n  return (\n    (!circular[0] && pos === range[0] - bounce[0]) ||\n    (!circular[1] && pos === range[1] + bounce[1])\n  );\n};\n\nexport const getDuration = (distance: number, deceleration): number => {\n  const duration = Math.sqrt((distance / deceleration) * 2);\n\n  // when duration is under 100, then value is zero\n  return duration < 100 ? 0 : duration;\n};\n\nexport const isCircularable = (\n  destPos: number,\n  range: number[],\n  circular: boolean[]\n): boolean => {\n  return (\n    (circular[1] && destPos > range[1]) || (circular[0] && destPos < range[0])\n  );\n};\n\nexport const getCirculatedPos = (\n  pos: number,\n  range: number[],\n  circular: boolean[]\n): number => {\n  let toPos = pos;\n  const min = range[0];\n  const max = range[1];\n  const length = max - min;\n\n  if (circular[1] && pos > max) {\n    // right\n    toPos = ((toPos - max) % length) + min;\n  }\n  if (circular[0] && pos < min) {\n    // left\n    toPos = ((toPos - min) % length) + max;\n  }\n  return toPos;\n};\n","/* eslint-disable no-new-func, no-nested-ternary */\n\nlet win: any;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {\n    navigator: {\n      userAgent: \"\",\n    },\n  };\n} else {\n  win = window;\n}\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexport { win as window };\n","import { window } from \"./browser\";\nimport { PREVENT_SCROLL_CSSPROPS } from \"./const\";\nimport { ObjectInterface } from \"./types\";\n\ndeclare let jQuery: any;\n\nexport const toArray = (nodes: NodeList): HTMLElement[] => {\n  // const el = Array.prototype.slice.call(nodes);\n  // for IE8\n  const el = [];\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    el.push(nodes[i]);\n  }\n  return el;\n};\n\nexport const $ = (param, multi = false) => {\n  let el;\n\n  if (typeof param === \"string\") {\n    // String (HTML, Selector)\n    // check if string is HTML tag format\n    const match = param.match(/^<([a-z]+)\\s*([^>]*)>/);\n\n    // creating element\n    if (match) {\n      // HTML\n      const dummy = document.createElement(\"div\");\n\n      dummy.innerHTML = param;\n      el = toArray(dummy.childNodes);\n    } else {\n      // Selector\n      el = toArray(document.querySelectorAll(param));\n    }\n    if (!multi) {\n      el = el.length >= 1 ? el[0] : undefined;\n    }\n  } else if (param === window) {\n    // window\n    el = param;\n  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {\n    // HTMLElement, Document\n    el = param;\n  } else if (\n    (\"jQuery\" in window && param instanceof jQuery) ||\n    param.constructor.prototype.jquery\n  ) {\n    // jQuery\n    el = multi ? param.toArray() : param.get(0);\n  } else if (Array.isArray(param)) {\n    el = param.map((v) => $(v));\n    if (!multi) {\n      el = el.length >= 1 ? el[0] : undefined;\n    }\n  }\n  return el;\n};\n\nlet raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame;\nlet caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;\nif (raf && !caf) {\n  const keyInfo = {};\n  const oldraf = raf;\n  raf = (callback: FrameRequestCallback) => {\n    const wrapCallback = (timestamp: number) => {\n      if (keyInfo[key]) {\n        callback(timestamp);\n      }\n    };\n    const key = oldraf(wrapCallback);\n    keyInfo[key] = true;\n    return key;\n  };\n  caf = (key: number) => {\n    delete keyInfo[key];\n  };\n} else if (!(raf && caf)) {\n  raf = (callback: FrameRequestCallback) => {\n    return window.setTimeout(() => {\n      callback(\n        ((window.performance &&\n          window.performance.now &&\n          window.performance.now()) as number) || new Date().getTime()\n      );\n    }, 16);\n  };\n  caf = window.clearTimeout;\n}\n\n/**\n * A polyfill for the window.requestAnimationFrame() method.\n * @see  https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n * @private\n */\nexport const requestAnimationFrame = (fp) => {\n  return raf(fp);\n};\n/**\n * A polyfill for the window.cancelAnimationFrame() method. It cancels an animation executed through a call to the requestAnimationFrame() method.\n * @param {Number} key −\tThe ID value returned through a call to the requestAnimationFrame() method. <ko>requestAnimationFrame() 메서드가 반환한 아이디 값</ko>\n * @see  https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame\n * @private\n */\nexport const cancelAnimationFrame = (key) => {\n  caf(key);\n};\n\nexport const map = <T, U>(\n  obj: ObjectInterface<T>,\n  callback: (value: T, key: string) => U\n): ObjectInterface<U> => {\n  const tranformed: ObjectInterface<U> = {};\n\n  for (const k in obj) {\n    if (k) {\n      tranformed[k] = callback(obj[k], k);\n    }\n  }\n  return tranformed;\n};\n\nexport const filter = <T>(\n  obj: ObjectInterface<T>,\n  callback: (value: T, key: string) => boolean\n): ObjectInterface<T> => {\n  const filtered: ObjectInterface<T> = {};\n\n  for (const k in obj) {\n    if (k && callback(obj[k], k)) {\n      filtered[k] = obj[k];\n    }\n  }\n  return filtered;\n};\nexport const every = <T>(\n  obj: ObjectInterface<T>,\n  callback: (value: T, key: string) => boolean\n) => {\n  for (const k in obj) {\n    if (k && !callback(obj[k], k)) {\n      return false;\n    }\n  }\n  return true;\n};\nexport const equal = (\n  target: ObjectInterface,\n  base: ObjectInterface\n): boolean => {\n  return every(target, (v, k) => v === base[k]);\n};\n\nconst roundNumFunc = {};\n\nexport const roundNumber = (num: number, roundUnit: number) => {\n  // Cache for performance\n  if (!roundNumFunc[roundUnit]) {\n    roundNumFunc[roundUnit] = getRoundFunc(roundUnit);\n  }\n\n  return roundNumFunc[roundUnit](num);\n};\n\nexport const roundNumbers = (\n  num: ObjectInterface<number>,\n  roundUnit: ObjectInterface<number> | number\n): ObjectInterface<number> => {\n  if (!num || !roundUnit) {\n    return num;\n  }\n  return map(num, (value, key) =>\n    roundNumber(\n      value,\n      typeof roundUnit === \"number\" ? roundUnit : roundUnit[key]\n    )\n  );\n};\n\nexport const getDecimalPlace = (val: number): number => {\n  if (!isFinite(val)) {\n    return 0;\n  }\n\n  const v = `${val}`;\n\n  if (v.indexOf(\"e\") >= 0) {\n    // Exponential Format\n    // 1e-10, 1e-12\n    let p = 0;\n    let e = 1;\n\n    while (Math.round(val * e) / e !== val) {\n      e *= 10;\n      p++;\n    }\n\n    return p;\n  }\n\n  // In general, following has performance benefit.\n  // https://jsperf.com/precision-calculation\n  return v.indexOf(\".\") >= 0 ? v.length - v.indexOf(\".\") - 1 : 0;\n};\n\nexport const inversePow = (n: number) => {\n  // replace Math.pow(10, -n) to solve floating point issue.\n  // eg. Math.pow(10, -4) => 0.00009999999999999999\n  return 1 / Math.pow(10, n);\n};\n\nexport const getRoundFunc = (v: number) => {\n  const p = v < 1 ? Math.pow(10, getDecimalPlace(v)) : 1;\n\n  return (n: number) => {\n    if (v === 0) {\n      return 0;\n    }\n\n    return Math.round(Math.round(n / v) * v * p) / p;\n  };\n};\n\nexport const getAngle = (posX: number, posY: number) => {\n  return (Math.atan2(posY, posX) * 180) / Math.PI;\n};\n\nexport const setCssProps = (\n  element: HTMLElement,\n  originalCssProps?: { [key: string]: string }\n): { [key: string]: string } => {\n  const oldCssProps = {};\n  if (element && element.style) {\n    const newCssProps = originalCssProps\n      ? originalCssProps\n      : PREVENT_SCROLL_CSSPROPS;\n    Object.keys(newCssProps).forEach((prop) => {\n      oldCssProps[prop] = element.style[prop];\n      element.style[prop] = newCssProps[prop];\n    });\n  }\n  return oldCssProps;\n};\n","export const DIRECTION_NONE = 1;\nexport const DIRECTION_LEFT = 2;\nexport const DIRECTION_RIGHT = 4;\nexport const DIRECTION_HORIZONTAL = 2 | 4;\nexport const DIRECTION_UP = 8;\nexport const DIRECTION_DOWN = 16;\nexport const DIRECTION_VERTICAL = 8 | 16;\nexport const DIRECTION_ALL = 2 | 4 | 8 | 16;\n\nexport const MOUSE_LEFT = \"left\";\nexport const MOUSE_RIGHT = \"right\";\nexport const MOUSE_MIDDLE = \"middle\";\n\nimport getAgent from \"@egjs/agent\";\n\nimport { window } from \"./browser\";\n\nexport const IOS_EDGE_THRESHOLD = 30;\nexport const IS_IOS_SAFARI =\n  \"ontouchstart\" in window && getAgent().browser.name === \"safari\";\n\nexport const TRANSFORM = (() => {\n  if (typeof document === \"undefined\") {\n    return \"\";\n  }\n  const bodyStyle = (document.head || document.getElementsByTagName(\"head\")[0])\n    .style;\n  const target = [\n    \"transform\",\n    \"webkitTransform\",\n    \"msTransform\",\n    \"mozTransform\",\n  ];\n  for (let i = 0, len = target.length; i < len; i++) {\n    if (target[i] in bodyStyle) {\n      return target[i];\n    }\n  }\n  return \"\";\n})();\n\nexport const PREVENT_SCROLL_CSSPROPS = {\n  \"touch-action\": \"none\",\n  \"user-select\": \"none\",\n  \"-webkit-user-drag\": \"none\",\n};\n","import {\n  getInsidePosition,\n  isCircularable,\n  getCirculatedPos,\n  getDuration,\n} from \"./Coordinate\";\nimport { Axis, AxisManager } from \"./AxisManager\";\nimport { InterruptManager } from \"./InterruptManager\";\nimport { EventManager, ChangeEventOption } from \"./EventManager\";\nimport {\n  requestAnimationFrame,\n  cancelAnimationFrame,\n  map,\n  every,\n  filter,\n  equal,\n  roundNumber,\n  getDecimalPlace,\n  inversePow,\n} from \"./utils\";\nimport { AxesOption } from \"./Axes\";\nimport {\n  AnimationParam,\n  ObjectInterface,\n  UpdateAnimationOption,\n} from \"./types\";\n\nconst clamp = (value: number, min: number, max: number): number => {\n  return Math.max(Math.min(value, max), min);\n};\n\nexport class AnimationManager {\n  public interruptManager: InterruptManager;\n  public eventManager: EventManager;\n  public axisManager: AxisManager;\n  private _raf: number;\n  private _animateParam: AnimationParam;\n  private _initialEasingPer: number;\n  private _prevEasingPer: number;\n  private _durationOffset: number;\n  private _options: AxesOption;\n\n  public constructor({\n    options,\n    interruptManager,\n    eventManager,\n    axisManager,\n  }: {\n    options: AxesOption;\n    interruptManager: InterruptManager;\n    eventManager: EventManager;\n    axisManager: AxisManager;\n  }) {\n    this._options = options;\n    this.interruptManager = interruptManager;\n    this.eventManager = eventManager;\n    this.axisManager = axisManager;\n    this.animationEnd = this.animationEnd.bind(this);\n  }\n\n  public getDuration(\n    depaPos: Axis,\n    destPos: Axis,\n    wishDuration?: number\n  ): number {\n    let duration: number;\n    if (typeof wishDuration !== \"undefined\") {\n      duration = wishDuration;\n    } else {\n      const durations: Axis = map(destPos, (v, k) =>\n        getDuration(Math.abs(v - depaPos[k]), this._options.deceleration)\n      );\n      duration = Object.keys(durations).reduce(\n        (max, v) => Math.max(max, durations[v]),\n        -Infinity\n      );\n    }\n    return clamp(\n      duration,\n      this._options.minimumDuration,\n      this._options.maximumDuration\n    );\n  }\n\n  public getDisplacement(velocity: number[]): number[] {\n    const totalVelocity = Math.pow(\n      velocity.reduce((total, v) => total + v * v, 0),\n      1 / velocity.length\n    );\n    const duration = Math.abs(totalVelocity / -this._options.deceleration);\n    return velocity.map((v) => (v / 2) * duration);\n  }\n\n  public interpolate(displacement: number, threshold: number): number {\n    const initSlope = this.easing(0.00001) / 0.00001;\n    return this.easing(displacement / (threshold * initSlope)) * threshold;\n  }\n\n  public stopAnimation(option?: ChangeEventOption): void {\n    if (this._animateParam) {\n      const orgPos: Axis = this.axisManager.get();\n      const pos: Axis = this.axisManager.map(orgPos, (v, opt) =>\n        getCirculatedPos(v, opt.range, opt.circular as boolean[])\n      );\n      if (!every(pos, (v, k) => orgPos[k] === v)) {\n        this.eventManager.triggerChange(pos, orgPos, option, !!option);\n      }\n      this._animateParam = null;\n      if (this._raf) {\n        cancelAnimationFrame(this._raf);\n      }\n      this._raf = null;\n      this.eventManager.triggerAnimationEnd(!!option?.event);\n    }\n  }\n\n  public getEventInfo(): ChangeEventOption {\n    if (\n      this._animateParam &&\n      this._animateParam.input &&\n      this._animateParam.inputEvent\n    ) {\n      return {\n        input: this._animateParam.input,\n        event: this._animateParam.inputEvent,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  public restore(option: ChangeEventOption): void {\n    const pos: Axis = this.axisManager.get();\n    const destPos: Axis = this.axisManager.map(pos, (v, opt) =>\n      Math.min(opt.range[1], Math.max(opt.range[0], v))\n    );\n    this.stopAnimation();\n    this.animateTo(destPos, this.getDuration(pos, destPos), option);\n  }\n\n  public animationEnd(): void {\n    const beforeParam: ChangeEventOption = this.getEventInfo();\n    this._animateParam = null;\n\n    // for Circular\n    const circularTargets = this.axisManager.filter(\n      this.axisManager.get(),\n      (v, opt) => isCircularable(v, opt.range, opt.circular as boolean[])\n    );\n    if (Object.keys(circularTargets).length > 0) {\n      this.setTo(\n        this.axisManager.map(circularTargets, (v, opt) =>\n          getCirculatedPos(v, opt.range, opt.circular as boolean[])\n        )\n      );\n    }\n    this.interruptManager.setInterrupt(false);\n    this.eventManager.triggerAnimationEnd(!!beforeParam);\n    if (this.axisManager.isOutside()) {\n      this.restore(beforeParam);\n    } else {\n      this.finish(!!beforeParam);\n    }\n  }\n\n  public finish(isTrusted: boolean): void {\n    this._animateParam = null;\n    this.interruptManager.setInterrupt(false);\n    this.eventManager.triggerFinish(isTrusted);\n  }\n\n  public getUserControl(param: AnimationParam): {\n    destPos: Axis;\n    duration: number;\n  } {\n    const userWish = param.setTo();\n    userWish.destPos = this.axisManager.get(userWish.destPos);\n    userWish.duration = clamp(\n      userWish.duration,\n      this._options.minimumDuration,\n      this._options.maximumDuration\n    );\n    return userWish;\n  }\n\n  public animateTo(\n    destPos: Axis,\n    duration: number,\n    option?: ChangeEventOption\n  ): void {\n    this.stopAnimation();\n    const param: AnimationParam = this._createAnimationParam(\n      destPos,\n      duration,\n      option\n    );\n    const depaPos = { ...param.depaPos };\n    const retTrigger = this.eventManager.triggerAnimationStart(param);\n\n    // to control\n    const userWish = this.getUserControl(param);\n\n    // You can't stop the 'animationStart' event when 'circular' is true.\n    if (\n      !retTrigger &&\n      this.axisManager.every(userWish.destPos, (v, opt) =>\n        isCircularable(v, opt.range, opt.circular as boolean[])\n      )\n    ) {\n      console.warn(\n        \"You can't stop the 'animation' event when 'circular' is true.\"\n      );\n    }\n\n    if (retTrigger && !equal(userWish.destPos, depaPos)) {\n      const inputEvent = option?.event || null;\n      this._animateLoop(\n        {\n          depaPos,\n          destPos: userWish.destPos,\n          duration: userWish.duration,\n          delta: this.axisManager.getDelta(depaPos, userWish.destPos),\n          isTrusted: !!inputEvent,\n          inputEvent,\n          input: option?.input || null,\n        },\n        () => this.animationEnd()\n      );\n    }\n  }\n\n  public easing(p: number): number {\n    return p > 1 ? 1 : this._options.easing(p);\n  }\n\n  public setTo(pos: Axis, duration: number = 0) {\n    const axes: string[] = Object.keys(pos);\n    const orgPos: Axis = this.axisManager.get(axes);\n\n    if (equal(pos, orgPos)) {\n      return this;\n    }\n    this.interruptManager.setInterrupt(true);\n    let movedPos = filter(pos, (v, k) => orgPos[k] !== v);\n    if (!Object.keys(movedPos).length) {\n      return this;\n    }\n\n    movedPos = this.axisManager.map(movedPos, (v, opt) => {\n      const { range, circular } = opt;\n\n      if (circular && (circular[0] || circular[1])) {\n        return v;\n      } else {\n        return getInsidePosition(v, range, circular as boolean[]);\n      }\n    });\n\n    if (equal(movedPos, orgPos)) {\n      return this;\n    }\n\n    if (duration > 0) {\n      this.animateTo(movedPos, duration);\n    } else {\n      this.stopAnimation();\n      this.eventManager.triggerChange(movedPos);\n      this.finish(false);\n    }\n\n    return this;\n  }\n\n  public setBy(pos: Axis, duration = 0) {\n    return this.setTo(\n      map(this.axisManager.get(Object.keys(pos)), (v, k) => v + pos[k]),\n      duration\n    );\n  }\n\n  public updateAnimation(options: UpdateAnimationOption): void {\n    const animateParam = this._animateParam;\n    if (!animateParam) {\n      return;\n    }\n\n    const diffTime = new Date().getTime() - animateParam.startTime;\n    const pos = options?.destPos || animateParam.destPos;\n    const duration = options?.duration || animateParam.duration;\n    if (options?.restart || duration <= diffTime) {\n      this.setTo(pos, duration - diffTime);\n      return;\n    }\n    if (options?.destPos) {\n      const currentPos = this.axisManager.get();\n      // When destination is changed, new delta should be calculated as remaining percent.\n      // For example, moving x:0, y:0 to x:200, y:200 and it has current easing percent of 92%. coordinate is x:184 and y:184\n      // If destination changes to x:300, y:300. xdelta:200, ydelta:200 changes to xdelta:116, ydelta:116 and use remaining easingPer as 100%, not 8% as previous.\n      // Therefore, original easingPer by time is kept. And divided by (1 - self._initialEasingPer) which means new total easing percent. Like calculating 8% as 100%.\n      this._initialEasingPer = this._prevEasingPer;\n      animateParam.delta = this.axisManager.getDelta(currentPos, pos);\n      animateParam.destPos = pos;\n    }\n    if (options?.duration) {\n      const ratio = (diffTime + this._durationOffset) / animateParam.duration;\n      // Use durationOffset for keeping animation ratio after duration is changed.\n      // newRatio = (diffTime + newDurationOffset) / newDuration = oldRatio\n      // newDurationOffset = oldRatio * newDuration - diffTime\n      this._durationOffset = ratio * duration - diffTime;\n      animateParam.duration = duration;\n    }\n  }\n\n  private _createAnimationParam(\n    pos: Axis,\n    duration: number,\n    option?: ChangeEventOption\n  ): AnimationParam {\n    const depaPos: Axis = this.axisManager.get();\n    const destPos: Axis = pos;\n    const inputEvent = option?.event || null;\n    return {\n      depaPos,\n      destPos,\n      duration: clamp(\n        duration,\n        this._options.minimumDuration,\n        this._options.maximumDuration\n      ),\n      delta: this.axisManager.getDelta(depaPos, destPos),\n      inputEvent,\n      input: option?.input || null,\n      isTrusted: !!inputEvent,\n      done: this.animationEnd,\n    };\n  }\n\n  private _animateLoop(param: AnimationParam, complete: () => void): void {\n    if (param.duration) {\n      let prevPos = param.depaPos;\n      this._initialEasingPer = 0;\n      this._prevEasingPer = 0;\n      this._durationOffset = 0;\n      this._animateParam = {\n        ...param,\n        startTime: new Date().getTime(),\n      };\n      const directions = map(prevPos, (value, key) => {\n        return value <= param.destPos[key] ? 1 : -1;\n      });\n      const originalIntendedPos = map(param.destPos, (v) => v);\n      const loop = () => {\n        const animateParam = this._animateParam;\n        const diffTime = new Date().getTime() - animateParam.startTime;\n        const ratio = (diffTime + this._durationOffset) / animateParam.duration;\n        const easingPer = this.easing(ratio);\n        this._raf = null;\n        const toPos: Axis = this.axisManager.map(\n          prevPos,\n          (pos, options, key) => {\n            const nextPos =\n              ratio >= 1\n                ? animateParam.destPos[key]\n                : pos +\n                  (animateParam.delta[key] *\n                    (easingPer - this._prevEasingPer)) /\n                    (1 - this._initialEasingPer);\n\n            // Subtract distance from distance already moved.\n            // Recalculate the remaining distance.\n            // Fix the bouncing phenomenon by changing the range.\n            const circulatedPos = getCirculatedPos(\n              nextPos,\n              options.range,\n              options.circular as boolean[]\n            );\n            if (nextPos !== circulatedPos) {\n              // circular\n              const rangeOffset =\n                directions[key] * (options.range[1] - options.range[0]);\n\n              animateParam.destPos[key] -= rangeOffset;\n              prevPos[key] -= rangeOffset;\n            }\n            return circulatedPos;\n          }\n        );\n        const isCanceled = !this.eventManager.triggerChange(toPos, prevPos);\n\n        prevPos = toPos;\n        this._prevEasingPer = easingPer;\n        if (easingPer >= 1) {\n          animateParam.destPos = this._getFinalPos(\n            animateParam.destPos,\n            originalIntendedPos\n          );\n\n          if (\n            !equal(\n              animateParam.destPos,\n              this.axisManager.get(Object.keys(animateParam.destPos))\n            )\n          ) {\n            this.eventManager.triggerChange(animateParam.destPos, prevPos);\n          }\n          complete();\n          return;\n        } else if (isCanceled) {\n          this.finish(false);\n        } else {\n          // animationEnd\n          this._raf = requestAnimationFrame(loop);\n        }\n      };\n      loop();\n    } else {\n      this.eventManager.triggerChange(param.destPos);\n      complete();\n    }\n  }\n\n  /**\n   * Get estimated final value.\n   *\n   * If destPos is within the 'error range' of the original intended position, the initial intended position is returned.\n   *   - eg. original intended pos: 100, destPos: 100.0000000004 ==> return 100;\n   * If dest Pos is outside the 'range of error' compared to the originally intended pos, it is returned rounded based on the originally intended pos.\n   *   - eg. original intended pos: 100.123 destPos: 50.12345 => return 50.123\n   * @param originalIntendedPos\n   * @param destPos\n   */\n  private _getFinalPos(\n    destPos: ObjectInterface<number>,\n    originalIntendedPos: ObjectInterface<number>\n  ): Axis {\n    // compare destPos and originalIntendedPos\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const ERROR_LIMIT = 0.000001;\n    const finalPos = map(destPos, (value, key) => {\n      if (\n        value >= originalIntendedPos[key] - ERROR_LIMIT &&\n        value <= originalIntendedPos[key] + ERROR_LIMIT\n      ) {\n        // In error range, return original intended\n        return originalIntendedPos[key];\n      } else {\n        // Out of error range, return rounded pos.\n        const roundUnit = this._getRoundUnit(value, key);\n        const result = roundNumber(value, roundUnit);\n        return result;\n      }\n    });\n    return finalPos;\n  }\n\n  private _getRoundUnit(val: number, key: string): number {\n    const roundUnit = this._options.round; // manual mode\n    let minRoundUnit = null; // auto mode\n\n    // auto mode\n    if (!roundUnit) {\n      // Get minimum round unit\n      const options = this.axisManager.getAxisOptions(key);\n      minRoundUnit = inversePow(\n        Math.max(\n          getDecimalPlace(options.range[0]),\n          getDecimalPlace(options.range[1]),\n          getDecimalPlace(val)\n        )\n      );\n    }\n\n    return minRoundUnit || roundUnit;\n  }\n}\n","import { Axis } from \"../AxisManager\";\nimport { AxesOption } from \"../Axes\";\nimport { ActiveEvent } from \"../types\";\nimport { MouseEventInput } from \"../eventInput/MouseEventInput\";\nimport { TouchEventInput } from \"../eventInput/TouchEventInput\";\nimport { PointerEventInput } from \"../eventInput/PointerEventInput\";\nimport { TouchMouseEventInput } from \"../eventInput/TouchMouseEventInput\";\nimport {\n  SUPPORT_POINTER_EVENTS,\n  SUPPORT_TOUCH,\n} from \"../eventInput/EventInput\";\n\nexport interface InputType {\n  axes: string[];\n  element: HTMLElement;\n  mapAxes(axes: string[]);\n  connect(observer: InputTypeObserver): InputType;\n  disconnect();\n  destroy();\n  enable?();\n  disable?();\n  isEnable?(): boolean;\n}\n\nexport interface InputTypeObserver {\n  options: AxesOption;\n  get(inputType: InputType): Axis;\n  change(inputType: InputType, event, offset: Axis, useDuration?: boolean);\n  hold(inputType: InputType, event);\n  release(\n    inputType: InputType,\n    event,\n    velocity: number[],\n    inputDuration?: number\n  );\n}\n\nexport const toAxis = (source: string[], offset: number[]): Axis => {\n  return offset.reduce((acc, v, i) => {\n    if (source[i]) {\n      acc[source[i]] = v;\n    }\n    return acc;\n  }, {});\n};\n\nexport const convertInputType = (inputType: string[] = []): ActiveEvent => {\n  let hasTouch = false;\n  let hasMouse = false;\n  let hasPointer = false;\n\n  inputType.forEach((v) => {\n    switch (v) {\n      case \"mouse\":\n        hasMouse = true;\n        break;\n      case \"touch\":\n        hasTouch = SUPPORT_TOUCH;\n        break;\n      case \"pointer\":\n        hasPointer = SUPPORT_POINTER_EVENTS;\n      // no default\n    }\n  });\n  if (hasPointer) {\n    return new PointerEventInput();\n  } else if (hasTouch && hasMouse) {\n    return new TouchMouseEventInput();\n  } else if (hasTouch) {\n    return new TouchEventInput();\n  } else if (hasMouse) {\n    return new MouseEventInput();\n  }\n  return null;\n};\n","import { $, setCssProps } from \"../utils\";\nimport {\n  IS_IOS_SAFARI,\n  IOS_EDGE_THRESHOLD,\n  DIRECTION_NONE,\n  DIRECTION_VERTICAL,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_ALL,\n  PREVENT_SCROLL_CSSPROPS,\n  MOUSE_LEFT,\n} from \"../const\";\nimport { ActiveEvent, InputEventType } from \"../types\";\n\nimport {\n  convertInputType,\n  InputType,\n  InputTypeObserver,\n  toAxis,\n} from \"./InputType\";\n\nexport interface PanInputOption {\n  inputType?: string[];\n  inputButton?: string[];\n  scale?: number[];\n  thresholdAngle?: number;\n  threshold?: number;\n  iOSEdgeSwipeThreshold?: number;\n  releaseOnScroll?: boolean;\n}\n\n// get user's direction\nexport const getDirectionByAngle = (\n  angle: number,\n  thresholdAngle: number\n): number => {\n  if (thresholdAngle < 0 || thresholdAngle > 90) {\n    return DIRECTION_NONE;\n  }\n  const toAngle = Math.abs(angle);\n\n  return toAngle > thresholdAngle && toAngle < 180 - thresholdAngle\n    ? DIRECTION_VERTICAL\n    : DIRECTION_HORIZONTAL;\n};\n\nexport const useDirection = (checkType, direction, userDirection?): boolean => {\n  if (userDirection) {\n    return !!(\n      direction === DIRECTION_ALL ||\n      (direction & checkType && userDirection & checkType)\n    );\n  } else {\n    return !!(direction & checkType);\n  }\n};\n\n/**\n * @typedef {Object} PanInputOption The option object of the eg.Axes.PanInput module.\n * @ko eg.Axes.PanInput 모듈의 옵션 객체\n * @param {String[]} [inputType=[\"touch\",\"mouse\", \"pointer\"]] Types of input devices\n * - touch: Touch screen\n * - mouse: Mouse <ko>입력 장치 종류\n * - touch: 터치 입력 장치\n * - mouse: 마우스</ko>\n * @param {String[]} [inputButton=[\"left\"]] List of buttons to allow input\n * - left: Left mouse button and normal touch\n * - middle: Mouse wheel press\n * - right: Right mouse button <ko>입력을 허용할 버튼 목록\n * - left: 마우스 왼쪽 버튼\n * - middle: 마우스 휠 눌림\n * - right: 마우스 오른쪽 버튼 </ko>\n * @param {Number[]} [scale] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @param {Number} [scale[0]=1] horizontal axis scale <ko>수평축 배율</ko>\n * @param {Number} [scale[1]=1] vertical axis scale <ko>수직축 배율</ko>\n * @param {Number} [thresholdAngle=45] The threshold value that determines whether user action is horizontal or vertical (0~90) <ko>사용자의 동작이 가로 방향인지 세로 방향인지 판단하는 기준 각도(0~90)</ko>\n * @param {Number} [threshold=0] Minimal pan distance required before recognizing <ko>사용자의 Pan 동작을 인식하기 위해산 최소한의 거리</ko>\n * @param {Number} [iOSEdgeSwipeThreshold=30] Area (px) that can go to the next page when swiping the right edge in iOS safari <ko>iOS Safari에서 오른쪽 엣지를 스와이프 하는 경우 다음 페이지로 넘어갈 수 있는 영역(px)</ko>\n **/\n/**\n * A module that passes the amount of change to eg.Axes when the mouse or touchscreen is down and moved. use less than two axes.\n * @ko 마우스나 터치 스크린을 누르고 움직일때의 변화량을 eg.Axes에 전달하는 모듈. 두개 이하의 축을 사용한다.\n *\n * @example\n * ```js\n * const pan = new eg.Axes.PanInput(\"#area\", {\n * \t\tinputType: [\"touch\"],\n * \t\tscale: [1, 1.3],\n * });\n *\n * // Connect the 'something2' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.\n * // Connect the 'somethingN' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.\n * axes.connect([\"something2\", \"somethingN\"], pan); // or axes.connect(\"something2 somethingN\", pan);\n *\n * // Connect only one 'something1' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.\n * axes.connect([\"something1\"], pan); // or axes.connect(\"something1\", pan);\n *\n * // Connect only one 'something2' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.\n * axes.connect([\"\", \"something2\"], pan); // or axes.connect(\" something2\", pan);\n * ```\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.PanInput module <ko>eg.Axes.PanInput 모듈을 사용할 엘리먼트</ko>\n * @param {PanInputOption} [options={}] The option object of the eg.Axes.PanInput module<ko>eg.Axes.PanInput 모듈의 옵션 객체</ko>\n */\nexport class PanInput implements InputType {\n  public options: PanInputOption;\n  public axes: string[] = [];\n  public element: HTMLElement = null;\n  protected _observer: InputTypeObserver;\n  protected _direction;\n  protected _enabled = false;\n  protected _activeEvent: ActiveEvent = null;\n  private _originalCssProps: { [key: string]: string };\n  private _atRightEdge = false;\n  private _rightEdgeTimer = 0;\n\n  /**\n   *\n   */\n  public constructor(el: string | HTMLElement, options?: PanInputOption) {\n    this.element = $(el);\n    this.options = {\n      inputType: [\"touch\", \"mouse\", \"pointer\"],\n      inputButton: [MOUSE_LEFT],\n      scale: [1, 1],\n      thresholdAngle: 45,\n      threshold: 0,\n      iOSEdgeSwipeThreshold: IOS_EDGE_THRESHOLD,\n      releaseOnScroll: false,\n      ...options,\n    };\n    this._onPanstart = this._onPanstart.bind(this);\n    this._onPanmove = this._onPanmove.bind(this);\n    this._onPanend = this._onPanend.bind(this);\n  }\n\n  public mapAxes(axes: string[]) {\n    const useHorizontal = !!axes[0];\n    const useVertical = !!axes[1];\n    if (useHorizontal && useVertical) {\n      this._direction = DIRECTION_ALL;\n    } else if (useHorizontal) {\n      this._direction = DIRECTION_HORIZONTAL;\n    } else if (useVertical) {\n      this._direction = DIRECTION_VERTICAL;\n    } else {\n      this._direction = DIRECTION_NONE;\n    }\n    this.axes = axes;\n  }\n\n  public connect(observer: InputTypeObserver): InputType {\n    if (this._activeEvent) {\n      this._detachElementEvent();\n      this._detachWindowEvent(this._activeEvent);\n    }\n    this._attachElementEvent(observer);\n    this._originalCssProps = setCssProps(this.element);\n    return this;\n  }\n\n  public disconnect() {\n    this._detachElementEvent();\n    this._detachWindowEvent(this._activeEvent);\n    if (this._originalCssProps !== PREVENT_SCROLL_CSSPROPS) {\n      setCssProps(this.element, this._originalCssProps);\n    }\n    this._direction = DIRECTION_NONE;\n    return this;\n  }\n\n  /**\n   * Destroys elements, properties, and events used in a module.\n   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n   */\n  public destroy() {\n    this.disconnect();\n    this.element = null;\n  }\n\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enable() {\n    this._enabled = true;\n    return this;\n  }\n\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disable() {\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  protected _onPanstart(event: InputEventType) {\n    const activeEvent = this._activeEvent;\n    const panEvent = activeEvent.onEventStart(event, this.options.inputButton);\n    if (!panEvent || !this._enabled || activeEvent.getTouches(event) > 1) {\n      return;\n    }\n\n    if (panEvent.srcEvent.cancelable !== false) {\n      const edgeThreshold = this.options.iOSEdgeSwipeThreshold;\n\n      this._observer.hold(this, panEvent);\n      this._atRightEdge =\n        IS_IOS_SAFARI && panEvent.center.x > window.innerWidth - edgeThreshold;\n      this._attachWindowEvent(activeEvent);\n      activeEvent.prevEvent = panEvent;\n    }\n  }\n\n  protected _onPanmove(event: InputEventType) {\n    const activeEvent = this._activeEvent;\n    const panEvent = activeEvent.onEventMove(event, this.options.inputButton);\n    if (!panEvent || !this._enabled || activeEvent.getTouches(event) > 1) {\n      return;\n    }\n\n    const { iOSEdgeSwipeThreshold, releaseOnScroll } = this.options;\n    const userDirection = getDirectionByAngle(\n      panEvent.angle,\n      this.options.thresholdAngle\n    );\n\n    if (releaseOnScroll && !panEvent.srcEvent.cancelable) {\n      this._onPanend(event);\n      return;\n    }\n\n    if (activeEvent.prevEvent && IS_IOS_SAFARI) {\n      const swipeLeftToRight = panEvent.center.x < 0;\n\n      if (swipeLeftToRight) {\n        // iOS swipe left => right\n        this._forceRelease();\n        return;\n      } else if (this._atRightEdge) {\n        clearTimeout(this._rightEdgeTimer);\n\n        // - is right to left\n        const swipeRightToLeft = panEvent.deltaX < -iOSEdgeSwipeThreshold;\n\n        if (swipeRightToLeft) {\n          this._atRightEdge = false;\n        } else {\n          // iOS swipe right => left\n          this._rightEdgeTimer = window.setTimeout(\n            () => this._forceRelease(),\n            100\n          );\n        }\n      }\n    }\n    const offset: number[] = this._getOffset(\n      [panEvent.offsetX, panEvent.offsetY],\n      [\n        useDirection(DIRECTION_HORIZONTAL, this._direction, userDirection),\n        useDirection(DIRECTION_VERTICAL, this._direction, userDirection),\n      ]\n    );\n    const prevent = offset.some((v) => v !== 0);\n\n    if (prevent) {\n      if (panEvent.srcEvent.cancelable !== false) {\n        panEvent.srcEvent.preventDefault();\n      }\n      panEvent.srcEvent.stopPropagation();\n    }\n    panEvent.preventSystemEvent = prevent;\n    if (prevent) {\n      this._observer.change(this, panEvent, toAxis(this.axes, offset));\n    }\n    activeEvent.prevEvent = panEvent;\n  }\n\n  protected _onPanend(event: InputEventType) {\n    const activeEvent = this._activeEvent;\n    activeEvent.onEventEnd(event);\n    if (!this._enabled || activeEvent.getTouches(event) !== 0) {\n      return;\n    }\n    this._detachWindowEvent(activeEvent);\n    clearTimeout(this._rightEdgeTimer);\n    const prevEvent = activeEvent.prevEvent;\n    const velocity = this._getOffset(\n      [\n        Math.abs(prevEvent.velocityX) * (prevEvent.offsetX < 0 ? -1 : 1),\n        Math.abs(prevEvent.velocityY) * (prevEvent.offsetY < 0 ? -1 : 1),\n      ],\n      [\n        useDirection(DIRECTION_HORIZONTAL, this._direction),\n        useDirection(DIRECTION_VERTICAL, this._direction),\n      ]\n    );\n    this._observer.release(this, prevEvent, velocity);\n    activeEvent.onRelease();\n  }\n\n  protected _attachWindowEvent(activeEvent: ActiveEvent) {\n    activeEvent?.move.forEach((event) => {\n      window.addEventListener(event, this._onPanmove);\n    });\n    activeEvent?.end.forEach((event) => {\n      window.addEventListener(event, this._onPanend);\n    });\n  }\n\n  protected _detachWindowEvent(activeEvent: ActiveEvent) {\n    activeEvent?.move.forEach((event) => {\n      window.removeEventListener(event, this._onPanmove);\n    });\n    activeEvent?.end.forEach((event) => {\n      window.removeEventListener(event, this._onPanend);\n    });\n  }\n\n  private _attachElementEvent(observer: InputTypeObserver) {\n    const activeEvent = convertInputType(this.options.inputType);\n    if (!activeEvent) {\n      throw new Error(\n        \"There is currently no inputType available for current device. There must be at least one available inputType.\"\n      );\n    }\n    this._observer = observer;\n    this._enabled = true;\n    this._activeEvent = activeEvent;\n    activeEvent?.start.forEach((event) => {\n      this.element?.addEventListener(event, this._onPanstart);\n    });\n  }\n\n  private _detachElementEvent() {\n    const activeEvent = this._activeEvent;\n    activeEvent?.start.forEach((event) => {\n      this.element?.removeEventListener(event, this._onPanstart);\n    });\n    this._enabled = false;\n    this._observer = null;\n  }\n\n  private _getOffset(properties: number[], direction: boolean[]): number[] {\n    const offset: number[] = [0, 0];\n    const scale = this.options.scale;\n\n    if (direction[0]) {\n      offset[0] = properties[0] * scale[0];\n    }\n    if (direction[1]) {\n      offset[1] = properties[1] * scale[1];\n    }\n    return offset;\n  }\n\n  private _forceRelease = () => {\n    const activeEvent = this._activeEvent;\n    this._detachWindowEvent(activeEvent);\n    this._observer.release(this, activeEvent.prevEvent, [0, 0]);\n    activeEvent.onRelease();\n  };\n}\n","import { ComponentEvent } from \"@egjs/component\";\n\nimport { InputType } from \"./inputType/InputType\";\nimport { Axis } from \"./AxisManager\";\nimport { AnimationManager } from \"./AnimationManager\";\nimport Axes from \"./Axes\";\nimport { roundNumbers } from \"./utils\";\nimport { AnimationParam, OnAnimationStart, OnRelease } from \"./types\";\n\nexport interface ChangeEventOption {\n  input: InputType;\n  event;\n}\n\nexport class EventManager {\n  public animationManager: AnimationManager;\n  public constructor(private _axes: Axes) {}\n  /**\n   * This event is fired when a user holds an element on the screen of the device.\n   * @ko 사용자가 기기의 화면에 손을 대고 있을 때 발생하는 이벤트\n   * @event Axes#hold\n   * @type {object}\n   * @property {Object.<string, number>} pos coordinate <ko>좌표 정보</ko>\n   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>\n   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"hold\", function(event) {\n   *   // event.pos\n   *   // event.input\n   *   // event.inputEvent\n   *   // isTrusted\n   * });\n   * ```\n   */\n  public hold(pos: Axis, option: ChangeEventOption) {\n    const { roundPos } = this._getRoundPos(pos);\n\n    this._axes.trigger(\n      new ComponentEvent(\"hold\", {\n        pos: roundPos,\n        input: option.input || null,\n        inputEvent: option.event || null,\n        isTrusted: true,\n      })\n    );\n  }\n\n  /**\n   * Specifies the coordinates to move after the 'change' event. It works when the holding value of the change event is true.\n   * @ko 'change' 이벤트 이후 이동할 좌표를 지정한다. change이벤트의 holding 값이 true일 경우에 동작한다\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"change\", function(event) {\n   *   event.holding && event.set({x: 10});\n   * });\n   * ```\n   */\n  /** Specifies the animation coordinates to move after the 'release' or 'animationStart' events.\n   * @ko 'release' 또는 'animationStart' 이벤트 이후 이동할 좌표를 지정한다.\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"animationStart\", function(event) {\n   *   event.setTo({x: 10}, 2000);\n   * });\n   * ```\n   */\n  /**\n   * This event is fired when a user release an element on the screen of the device.\n   * @ko 사용자가 기기의 화면에서 손을 뗐을 때 발생하는 이벤트\n   * @event Axes#release\n   * @type {object}\n   * @property {Object.<string, number>} depaPos The coordinates when releasing an element<ko>손을 뗐을 때의 좌표 </ko>\n   * @property {Object.<string, number>} destPos The coordinates to move to after releasing an element<ko>손을 뗀 뒤에 이동할 좌표</ko>\n   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>\n   * @property {Object.<string, number>} bounceRatio If the coordinates at the time of release are in the bounce area, the current bounce value divided by the maximum bounce value <ko>손을 뗐을 때의 좌표가 bounce 영역에 있는 경우 현재 bounce된 값을 최대 bounce 값으로 나눈 수치.</ko>\n   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>\n   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>\n   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"release\", function(event) {\n   *   // event.depaPos\n   *   // event.destPos\n   *   // event.delta\n   *   // event.input\n   *   // event.inputEvent\n   *   // event.setTo\n   *   // event.isTrusted\n   *\n   *   // if you want to change the animation coordinates to move after the 'release' event.\n   *   event.setTo({x: 10}, 2000);\n   * });\n   * ```\n   */\n  public triggerRelease(param: AnimationParam) {\n    const { roundPos, roundDepa } = this._getRoundPos(\n      param.destPos,\n      param.depaPos\n    );\n    param.destPos = roundPos;\n    param.depaPos = roundDepa;\n    param.setTo = this._createUserControll(param.destPos, param.duration);\n    this._axes.trigger(\n      new ComponentEvent(\"release\", {\n        ...param,\n        bounceRatio: this._getBounceRatio(roundPos),\n      } as OnRelease)\n    );\n  }\n\n  /**\n   * This event is fired when coordinate changes.\n   * @ko 좌표가 변경됐을 때 발생하는 이벤트\n   * @event Axes#change\n   * @type {object}\n   * @property {Object.<string, number>} pos  The coordinate <ko>좌표</ko>\n   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>\n   * @property {Object.<string, number>} bounceRatio If the current coordinates are in the bounce area, the current bounce value divided by the maximum bounce value <ko>현재 좌표가 bounce 영역에 있는 경우 현재 bounce된 값을 최대 bounce 값으로 나눈 수치.</ko>\n   * @property {Boolean} holding Indicates whether a user holds an element on the screen of the device.<ko>사용자가 기기의 화면을 누르고 있는지 여부</ko>\n   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns 'null'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>\n   * @property {Object} inputEvent The event object received from inputType. If the value is changed by animation, it returns 'null'.<ko>inputType으로 부터 받은 이벤트 객체. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>\n   * @property {set} set Specifies the coordinates to move after the event. It works when the holding value is true <ko>이벤트 이후 이동할 좌표를 지정한다. holding 값이 true일 경우에 동작한다.</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"change\", function(event) {\n   *   // event.pos\n   *   // event.delta\n   *   // event.input\n   *   // event.inputEvent\n   *   // event.holding\n   *   // event.set\n   *   // event.isTrusted\n   *\n   *   // if you want to change the coordinates to move after the 'change' event.\n   *   // it works when the holding value of the change event is true.\n   *   event.holding && event.set({x: 10});\n   * });\n   * ```\n   */\n  public triggerChange(\n    pos: Axis,\n    depaPos?: Axis,\n    option?: ChangeEventOption,\n    holding: boolean = false\n  ) {\n    const animationManager = this.animationManager;\n    const axisManager = animationManager.axisManager;\n    const eventInfo = animationManager.getEventInfo();\n    const { roundPos, roundDepa } = this._getRoundPos(pos, depaPos);\n    const moveTo = axisManager.moveTo(roundPos, roundDepa);\n    const inputEvent = option?.event || eventInfo?.event || null;\n    const param = {\n      pos: moveTo.pos,\n      delta: moveTo.delta,\n      bounceRatio: this._getBounceRatio(moveTo.pos),\n      holding,\n      inputEvent,\n      isTrusted: !!inputEvent,\n      input: option?.input || eventInfo?.input || null,\n      set: inputEvent ? this._createUserControll(moveTo.pos) : () => {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    };\n    const event = new ComponentEvent(\"change\", param);\n    this._axes.trigger(event);\n\n    if (inputEvent) {\n      axisManager.set(\n        (param.set() as { destPos: Axis; duration: number }).destPos\n      );\n    }\n\n    return !event.isCanceled();\n  }\n\n  /**\n   * This event is fired when animation starts.\n   * @ko 에니메이션이 시작할 때 발생한다.\n   * @event Axes#animationStart\n   * @type {object}\n   * @property {Object.<string, number>} depaPos The coordinates when animation starts<ko>애니메이션이 시작 되었을 때의 좌표 </ko>\n   * @property {Object.<string, number>} destPos The coordinates to move to. If you change this value, you can run the animation<ko>이동할 좌표. 이값을 변경하여 애니메이션을 동작시킬수 있다</ko>\n   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>\n   * @property {Number} duration Duration of the animation (unit: ms). If you change this value, you can control the animation duration time.<ko>애니메이션 진행 시간(단위: ms). 이값을 변경하여 애니메이션의 이동시간을 조절할 수 있다.</ko>\n   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns 'null'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>\n   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>\n   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"release\", function(event) {\n   *   // event.depaPos\n   *   // event.destPos\n   *   // event.delta\n   *   // event.input\n   *   // event.inputEvent\n   *   // event.setTo\n   *   // event.isTrusted\n   *\n   *   // if you want to change the animation coordinates to move after the 'animationStart' event.\n   *   event.setTo({x: 10}, 2000);\n   * });\n   * ```\n   */\n  public triggerAnimationStart(param: AnimationParam): boolean {\n    const { roundPos, roundDepa } = this._getRoundPos(\n      param.destPos,\n      param.depaPos\n    );\n    param.destPos = roundPos;\n    param.depaPos = roundDepa;\n    param.setTo = this._createUserControll(param.destPos, param.duration);\n    const event = new ComponentEvent(\n      \"animationStart\",\n      param as OnAnimationStart\n    );\n    this._axes.trigger(event);\n    return !event.isCanceled();\n  }\n\n  /**\n   * This event is fired when animation ends.\n   * @ko 에니메이션이 끝났을 때 발생한다.\n   * @event Axes#animationEnd\n   * @type {object}\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"animationEnd\", function(event) {\n   *   // event.isTrusted\n   * });\n   * ```\n   */\n  public triggerAnimationEnd(isTrusted: boolean = false) {\n    this._axes.trigger(\n      new ComponentEvent(\"animationEnd\", {\n        isTrusted,\n      })\n    );\n  }\n\n  /**\n   * This event is fired when all actions have been completed.\n   * @ko 에니메이션이 끝났을 때 발생한다.\n   * @event Axes#finish\n   * @type {object}\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"finish\", function(event) {\n   *   // event.isTrusted\n   * });\n   * ```\n   */\n  public triggerFinish(isTrusted: boolean = false) {\n    this._axes.trigger(\n      new ComponentEvent(\"finish\", {\n        isTrusted,\n      })\n    );\n  }\n\n  public setAnimationManager(animationManager: AnimationManager) {\n    this.animationManager = animationManager;\n  }\n\n  public destroy() {\n    this._axes.off();\n  }\n\n  private _createUserControll(pos: Axis, duration: number = 0) {\n    // to controll\n    const userControl = {\n      destPos: { ...pos },\n      duration,\n    };\n    return (\n      toPos?: Axis,\n      userDuration?: number\n    ): { destPos: Axis; duration: number } => {\n      if (toPos) {\n        userControl.destPos = { ...toPos };\n      }\n      if (userDuration !== undefined) {\n        userControl.duration = userDuration;\n      }\n      return userControl;\n    };\n  }\n\n  private _getRoundPos(pos: Axis, depaPos?: Axis) {\n    // round value if round exist\n    const roundUnit = this._axes.options.round;\n\n    // if (round == null) {\n    // \treturn {pos, depaPos}; // undefined, undefined\n    // }\n    return {\n      roundPos: roundNumbers(pos, roundUnit),\n      roundDepa: roundNumbers(depaPos, roundUnit),\n    };\n  }\n\n  private _getBounceRatio(pos: Axis): Axis {\n    return this._axes.axisManager.map(pos, (v, opt) => {\n      if (v < opt.range[0] && opt.bounce[0] !== 0) {\n        return (opt.range[0] - v) / opt.bounce[0];\n      } else if (v > opt.range[1] && opt.bounce[1] !== 0) {\n        return (v - opt.range[1]) / opt.bounce[1];\n      } else {\n        return 0;\n      }\n    });\n  }\n}\n","import { AxesOption } from \"./Axes\";\nexport class InterruptManager {\n  private _prevented = false; //  check whether the animation event was prevented\n  public constructor(private _options: AxesOption) {}\n\n  public isInterrupting() {\n    // when interruptable is 'true', return value is always 'true'.\n    return this._options.interruptable || this._prevented;\n  }\n\n  public isInterrupted() {\n    return !this._options.interruptable && this._prevented;\n  }\n\n  public setInterrupt(prevented) {\n    if (!this._options.interruptable) {\n      this._prevented = prevented;\n    }\n  }\n}\n","import { isOutside, getCirculatedPos } from \"./Coordinate\";\nimport { map, filter, every } from \"./utils\";\nimport { ObjectInterface } from \"./types\";\n\nexport interface Axis {\n  [key: string]: number;\n}\n\nexport interface AxisOption {\n  range?: number[];\n  bounce?: number | number[];\n  circular?: boolean | boolean[];\n}\n\nexport class AxisManager {\n  private _pos: Axis;\n  public constructor(private _axis: ObjectInterface<AxisOption>) {\n    this._complementOptions();\n    this._pos = Object.keys(this._axis).reduce((acc, v) => {\n      acc[v] = this._axis[v].range[0];\n      return acc;\n    }, {});\n  }\n\n  public getDelta(depaPos: Axis, destPos: Axis): Axis {\n    const fullDepaPos = this.get(depaPos);\n    return map(this.get(destPos), (v, k) => v - fullDepaPos[k]);\n  }\n\n  public get(axes?: string[] | Axis): Axis {\n    if (axes && Array.isArray(axes)) {\n      return axes.reduce((acc, v) => {\n        if (v && v in this._pos) {\n          acc[v] = this._pos[v];\n        }\n        return acc;\n      }, {});\n    } else {\n      return { ...this._pos, ...((axes || {}) as Axis) };\n    }\n  }\n\n  public moveTo(pos: Axis, depaPos: Axis = this._pos): { [key: string]: Axis } {\n    const delta = map(this._pos, (v, key) => {\n      return key in pos && key in depaPos ? pos[key] - depaPos[key] : 0;\n    });\n\n    this.set(\n      this.map(pos, (v, opt) =>\n        opt ? getCirculatedPos(v, opt.range, opt.circular as boolean[]) : 0\n      )\n    );\n    return {\n      pos: { ...this._pos },\n      delta,\n    };\n  }\n\n  public set(pos: Axis) {\n    for (const k in pos) {\n      if (k && k in this._pos) {\n        this._pos[k] = pos[k];\n      }\n    }\n  }\n\n  public every(\n    pos: Axis,\n    callback: (value: number, options: AxisOption, key: string) => boolean\n  ): boolean {\n    const axisOptions = this._axis;\n\n    return every(pos, (value, key) => callback(value, axisOptions[key], key));\n  }\n\n  public filter(\n    pos: Axis,\n    callback: (value: number, options: AxisOption, key: string) => boolean\n  ): Axis {\n    const axisOptions = this._axis;\n\n    return filter(pos, (value, key) => callback(value, axisOptions[key], key));\n  }\n\n  public map<U>(\n    pos: Axis,\n    callback: (value: number, options: AxisOption, key: string) => U\n  ) {\n    const axisOptions = this._axis;\n\n    return map<number, U>(pos, (value, key) =>\n      callback(value, axisOptions[key], key)\n    );\n  }\n\n  public isOutside(axes?: string[]) {\n    return !this.every(\n      axes ? this.get(axes) : this._pos,\n      (v, opt) => !isOutside(v, opt.range)\n    );\n  }\n\n  public getAxisOptions(key: string) {\n    return this._axis[key];\n  }\n\n  /**\n   * set up 'css' expression\n   * @private\n   */\n  private _complementOptions() {\n    Object.keys(this._axis).forEach((axis) => {\n      this._axis[axis] = {\n        ...{\n          range: [0, 100],\n          bounce: [0, 0],\n          circular: [false, false],\n        },\n        ...this._axis[axis],\n      };\n\n      [\"bounce\", \"circular\"].forEach((v) => {\n        const axisOption = this._axis;\n        const key = axisOption[axis][v];\n\n        if (/string|number|boolean/.test(typeof key)) {\n          axisOption[axis][v] = [key, key];\n        }\n      });\n    });\n  }\n}\n","import { ExtendedEvent, InputEventType } from \"../types\";\nimport { getAngle } from \"../utils\";\nimport { window } from \"../browser\";\nimport { MOUSE_LEFT, MOUSE_MIDDLE, MOUSE_RIGHT } from \"../const\";\n\nexport const SUPPORT_TOUCH = \"ontouchstart\" in window;\nexport const SUPPORT_POINTER = \"PointerEvent\" in window;\nexport const SUPPORT_MSPOINTER = \"MSPointerEvent\" in window;\nexport const SUPPORT_POINTER_EVENTS = SUPPORT_POINTER || SUPPORT_MSPOINTER;\n\nexport abstract class EventInput {\n  public prevEvent: ExtendedEvent;\n\n  public abstract onEventStart(\n    event: InputEventType,\n    inputButton?: string[]\n  ): ExtendedEvent;\n\n  public abstract onEventMove(\n    event: InputEventType,\n    inputButton?: string[]\n  ): ExtendedEvent;\n\n  public abstract onEventEnd(event: InputEventType): void;\n\n  public abstract onRelease(event: InputEventType): void;\n\n  public abstract getTouches(event: InputEventType): number;\n\n  protected abstract _getScale(event: InputEventType): number;\n\n  protected abstract _getCenter(event: InputEventType): {\n    x: number;\n    y: number;\n  };\n\n  protected abstract _getMovement(event: InputEventType): {\n    x: number;\n    y: number;\n  };\n\n  public extendEvent(event: InputEventType): ExtendedEvent {\n    const prevEvent = this.prevEvent;\n    const center = this._getCenter(event);\n    const movement = prevEvent ? this._getMovement(event) : { x: 0, y: 0 };\n    const scale = prevEvent ? this._getScale(event) : 1;\n    const angle = prevEvent\n      ? getAngle(center.x - prevEvent.center.x, center.y - prevEvent.center.y)\n      : 0;\n    const deltaX = prevEvent ? prevEvent.deltaX + movement.x : movement.x;\n    const deltaY = prevEvent ? prevEvent.deltaY + movement.y : movement.y;\n    const offsetX = prevEvent ? deltaX - prevEvent.deltaX : 0;\n    const offsetY = prevEvent ? deltaY - prevEvent.deltaY : 0;\n    const deltaTime = prevEvent\n      ? event.timeStamp - prevEvent.srcEvent.timeStamp\n      : 0;\n    const velocityX = prevEvent && deltaTime !== 0 ? offsetX / deltaTime : 0;\n    const velocityY = prevEvent && deltaTime !== 0 ? offsetY / deltaTime : 0;\n    return {\n      srcEvent: event,\n      scale,\n      angle,\n      center,\n      deltaX,\n      deltaY,\n      offsetX,\n      offsetY,\n      velocityX,\n      velocityY,\n      preventSystemEvent: true,\n    };\n  }\n\n  protected _getDistance(\n    start: Touch | PointerEvent,\n    end: Touch | PointerEvent\n  ): number {\n    const x = end.clientX - start.clientX;\n    const y = end.clientY - start.clientY;\n    return Math.sqrt(x * x + y * y);\n  }\n\n  protected _getButton(event: InputEventType): string {\n    const buttonCodeMap = { 1: MOUSE_LEFT, 2: MOUSE_RIGHT, 4: MOUSE_MIDDLE };\n    const button = this._isTouchEvent(event)\n      ? MOUSE_LEFT\n      : buttonCodeMap[event.buttons];\n    return button ? button : null;\n  }\n\n  protected _isTouchEvent(event: InputEventType): event is TouchEvent {\n    return event.type.indexOf(\"touch\") > -1;\n  }\n\n  protected _isValidButton(button: string, inputButton: string[]): boolean {\n    return inputButton.indexOf(button) > -1;\n  }\n\n  protected _preventMouseButton(event: InputEventType, button: string): void {\n    if (button === MOUSE_RIGHT) {\n      window.addEventListener(\"contextmenu\", this._stopContextMenu);\n    } else if (button === MOUSE_MIDDLE) {\n      event.preventDefault();\n    }\n  }\n\n  private _stopContextMenu = (event: InputEventType) => {\n    event.preventDefault();\n    window.removeEventListener(\"contextmenu\", this._stopContextMenu);\n  };\n}\n","import { InputEventType, ExtendedEvent } from \"../types\";\n\nimport { EventInput } from \"./EventInput\";\n\nexport class MouseEventInput extends EventInput {\n  public readonly start = [\"mousedown\"];\n  public readonly move = [\"mousemove\"];\n  public readonly end = [\"mouseup\"];\n\n  public onEventStart(\n    event: InputEventType,\n    inputButton?: string[]\n  ): ExtendedEvent {\n    const button = this._getButton(event);\n    if (inputButton && !this._isValidButton(button, inputButton)) {\n      return null;\n    }\n    this._preventMouseButton(event, button);\n    return this.extendEvent(event);\n  }\n\n  public onEventMove(\n    event: InputEventType,\n    inputButton?: string[]\n  ): ExtendedEvent {\n    if (\n      inputButton &&\n      !this._isValidButton(this._getButton(event), inputButton)\n    ) {\n      return null;\n    }\n    return this.extendEvent(event);\n  }\n\n  public onEventEnd(): void {\n    return;\n  }\n\n  public onRelease(): void {\n    this.prevEvent = null;\n    return;\n  }\n\n  public getTouches(): number {\n    return 0;\n  }\n\n  protected _getScale(): number {\n    return 1;\n  }\n\n  protected _getCenter(event: MouseEvent): { x: number; y: number } {\n    return {\n      x: event.clientX,\n      y: event.clientY,\n    };\n  }\n\n  protected _getMovement(event: MouseEvent): { x: number; y: number } {\n    const prev = this.prevEvent.srcEvent as MouseEvent;\n    return {\n      x: event.pageX - prev.pageX,\n      y: event.pageY - prev.pageY,\n    };\n  }\n}\n","import { InputEventType, ExtendedEvent } from \"../types\";\n\nimport { EventInput } from \"./EventInput\";\n\nexport class TouchEventInput extends EventInput {\n  public readonly start = [\"touchstart\"];\n  public readonly move = [\"touchmove\"];\n  public readonly end = [\"touchend\", \"touchcancel\"];\n\n  private _baseTouches: TouchList;\n\n  public onEventStart(event: InputEventType): ExtendedEvent {\n    this._baseTouches = (event as TouchEvent).touches;\n    return this.extendEvent(event);\n  }\n\n  public onEventMove(event: InputEventType): ExtendedEvent {\n    return this.extendEvent(event);\n  }\n\n  public onEventEnd(event: InputEventType): void {\n    this._baseTouches = (event as TouchEvent).touches;\n    return;\n  }\n\n  public onRelease(): void {\n    this.prevEvent = null;\n    this._baseTouches = null;\n    return;\n  }\n\n  public getTouches(event: InputEventType): number {\n    return (event as TouchEvent).touches.length;\n  }\n\n  protected _getScale(event: TouchEvent): number {\n    if (event.touches.length !== 2 || this._baseTouches.length < 2) {\n      return null; // TODO: consider calculating non-pinch gesture scale\n    }\n    return (\n      this._getDistance(event.touches[0], event.touches[1]) /\n      this._getDistance(this._baseTouches[0], this._baseTouches[1])\n    );\n  }\n\n  protected _getCenter(event: TouchEvent): { x: number; y: number } {\n    return {\n      x: event.touches[0].clientX,\n      y: event.touches[0].clientY,\n    };\n  }\n\n  protected _getMovement(event: TouchEvent): { x: number; y: number } {\n    const prev = this.prevEvent.srcEvent as TouchEvent;\n    if (event.touches[0].identifier !== prev.touches[0].identifier) {\n      return {\n        x: 0,\n        y: 0,\n      };\n    }\n    return {\n      x: event.touches[0].pageX - prev.touches[0].pageX,\n      y: event.touches[0].pageY - prev.touches[0].pageY,\n    };\n  }\n}\n","import { InputEventType, ExtendedEvent } from \"../types\";\n\nimport { EventInput, SUPPORT_POINTER } from \"./EventInput\";\n\nexport class PointerEventInput extends EventInput {\n  public readonly start = SUPPORT_POINTER ? [\"pointerdown\"] : [\"MSPointerDown\"];\n  public readonly move = SUPPORT_POINTER ? [\"pointermove\"] : [\"MSPointerMove\"];\n  public readonly end = SUPPORT_POINTER\n    ? [\"pointerup\", \"pointercancel\"]\n    : [\"MSPointerUp\", \"MSPointerCancel\"];\n\n  // store first, recent inputs for each event id\n  private _firstInputs: PointerEvent[] = [];\n  private _recentInputs: PointerEvent[] = [];\n\n  public onEventStart(\n    event: InputEventType,\n    inputButton?: string[]\n  ): ExtendedEvent {\n    const button = this._getButton(event);\n    if (inputButton && !this._isValidButton(button, inputButton)) {\n      return null;\n    }\n    this._preventMouseButton(event, button);\n    this._updatePointerEvent(event as PointerEvent);\n    return this.extendEvent(event);\n  }\n\n  public onEventMove(\n    event: InputEventType,\n    inputButton?: string[]\n  ): ExtendedEvent {\n    if (\n      inputButton &&\n      !this._isValidButton(this._getButton(event), inputButton)\n    ) {\n      return null;\n    }\n    this._updatePointerEvent(event as PointerEvent);\n    return this.extendEvent(event);\n  }\n\n  public onEventEnd(event: InputEventType): void {\n    this._removePointerEvent(event as PointerEvent);\n  }\n\n  public onRelease(): void {\n    this.prevEvent = null;\n    this._firstInputs = [];\n    this._recentInputs = [];\n    return;\n  }\n\n  public getTouches(): number {\n    return this._recentInputs.length;\n  }\n\n  protected _getScale(): number {\n    if (this._recentInputs.length !== 2) {\n      return null; // TODO: consider calculating non-pinch gesture scale\n    }\n    return (\n      this._getDistance(this._recentInputs[0], this._recentInputs[1]) /\n      this._getDistance(this._firstInputs[0], this._firstInputs[1])\n    );\n  }\n\n  protected _getCenter(event: PointerEvent): { x: number; y: number } {\n    return {\n      x: event.clientX,\n      y: event.clientY,\n    };\n  }\n\n  protected _getMovement(event: PointerEvent): { x: number; y: number } {\n    const prev = this.prevEvent.srcEvent as PointerEvent;\n    if (event.pointerId !== prev.pointerId) {\n      return {\n        x: 0,\n        y: 0,\n      };\n    }\n    return {\n      x: event.pageX - prev.pageX,\n      y: event.pageY - prev.pageY,\n    };\n  }\n\n  private _updatePointerEvent(event: PointerEvent) {\n    let addFlag = false;\n    this._recentInputs.forEach((e, i) => {\n      if (e.pointerId === event.pointerId) {\n        addFlag = true;\n        this._recentInputs[i] = event;\n      }\n    });\n    if (!addFlag) {\n      this._firstInputs.push(event);\n      this._recentInputs.push(event);\n    }\n  }\n\n  private _removePointerEvent(event?: PointerEvent) {\n    this._firstInputs = this._firstInputs.filter(\n      (x) => x.pointerId !== event.pointerId\n    );\n    this._recentInputs = this._recentInputs.filter(\n      (x) => x.pointerId !== event.pointerId\n    );\n  }\n}\n","import { InputEventType, ExtendedEvent } from \"../types\";\n\nimport { EventInput } from \"./EventInput\";\n\nexport class TouchMouseEventInput extends EventInput {\n  public readonly start = [\"mousedown\", \"touchstart\"];\n  public readonly move = [\"mousemove\", \"touchmove\"];\n  public readonly end = [\"mouseup\", \"touchend\", \"touchcancel\"];\n\n  private _baseTouches: TouchList;\n\n  public onEventStart(\n    event: InputEventType,\n    inputButton?: string[]\n  ): ExtendedEvent {\n    const button = this._getButton(event);\n    if (this._isTouchEvent(event)) {\n      this._baseTouches = event.touches;\n    }\n    if (inputButton && !this._isValidButton(button, inputButton)) {\n      return null;\n    }\n    this._preventMouseButton(event, button);\n    return this.extendEvent(event);\n  }\n\n  public onEventMove(\n    event: InputEventType,\n    inputButton?: string[]\n  ): ExtendedEvent {\n    if (\n      inputButton &&\n      !this._isValidButton(this._getButton(event), inputButton)\n    ) {\n      return null;\n    }\n    return this.extendEvent(event);\n  }\n\n  public onEventEnd(event: InputEventType): void {\n    if (this._isTouchEvent(event)) {\n      this._baseTouches = event.touches;\n    }\n    return;\n  }\n\n  public onRelease(): void {\n    this.prevEvent = null;\n    this._baseTouches = null;\n    return;\n  }\n\n  public getTouches(event: InputEventType): number {\n    return this._isTouchEvent(event) ? event.touches.length : 0;\n  }\n\n  protected _getScale(event: MouseEvent | TouchEvent): number {\n    if (this._isTouchEvent(event)) {\n      if (event.touches.length !== 2 || this._baseTouches.length < 2) {\n        return 1; // TODO: consider calculating non-pinch gesture scale\n      }\n      return (\n        this._getDistance(event.touches[0], event.touches[1]) /\n        this._getDistance(this._baseTouches[0], this._baseTouches[1])\n      );\n    }\n    return this.prevEvent.scale;\n  }\n\n  protected _getCenter(event: MouseEvent | TouchEvent): {\n    x: number;\n    y: number;\n  } {\n    if (this._isTouchEvent(event)) {\n      return {\n        x: event.touches[0].clientX,\n        y: event.touches[0].clientY,\n      };\n    }\n    return {\n      x: event.clientX,\n      y: event.clientY,\n    };\n  }\n\n  protected _getMovement(event: MouseEvent | TouchEvent): {\n    x: number;\n    y: number;\n  } {\n    const prev = this.prevEvent.srcEvent;\n    const [nextSpot, prevSpot] = [event, prev].map((e) => {\n      if (this._isTouchEvent(event)) {\n        return {\n          id: (e as TouchEvent).touches[0].identifier,\n          x: (e as TouchEvent).touches[0].pageX,\n          y: (e as TouchEvent).touches[0].pageY,\n        };\n      }\n      return {\n        id: null,\n        x: (e as MouseEvent).pageX,\n        y: (e as MouseEvent).pageY,\n      };\n    });\n    return nextSpot.id === prevSpot.id\n      ? { x: nextSpot.x - prevSpot.x, y: nextSpot.y - prevSpot.y }\n      : { x: 0, y: 0 };\n  }\n}\n","import { InterruptManager } from \"./InterruptManager\";\nimport { InputType, InputTypeObserver, toAxis } from \"./inputType/InputType\";\nimport { EventManager, ChangeEventOption } from \"./EventManager\";\nimport { AxisManager, Axis } from \"./AxisManager\";\nimport { AnimationManager } from \"./AnimationManager\";\nimport { AxesOption } from \"./Axes\";\nimport {\n  isOutside,\n  getInsidePosition,\n  getCirculatedPos,\n  isEndofBounce,\n} from \"./Coordinate\";\nimport { map, equal } from \"./utils\";\nimport { AnimationParam } from \"./types\";\n\nexport class InputObserver implements InputTypeObserver {\n  public options: AxesOption;\n  private _interruptManager: InterruptManager;\n  private _eventManager: EventManager;\n  private _axisManager: AxisManager;\n  private _animationManager: AnimationManager;\n  private _isOutside = false;\n  private _moveDistance: Axis = null;\n  private _isStopped = false;\n  public constructor({\n    options,\n    interruptManager,\n    eventManager,\n    axisManager,\n    animationManager,\n  }: {\n    options: AxesOption;\n    interruptManager: InterruptManager;\n    eventManager: EventManager;\n    axisManager: AxisManager;\n    animationManager: AnimationManager;\n  }) {\n    this.options = options;\n    this._interruptManager = interruptManager;\n    this._eventManager = eventManager;\n    this._axisManager = axisManager;\n    this._animationManager = animationManager;\n  }\n\n  public get(input: InputType): Axis {\n    return this._axisManager.get(input.axes);\n  }\n\n  public hold(input: InputType, event) {\n    if (this._interruptManager.isInterrupted() || !input.axes.length) {\n      return;\n    }\n    const changeOption: ChangeEventOption = {\n      input,\n      event,\n    };\n    this._isStopped = false;\n    this._interruptManager.setInterrupt(true);\n    this._animationManager.stopAnimation(changeOption);\n    if (!this._moveDistance) {\n      this._eventManager.hold(this._axisManager.get(), changeOption);\n    }\n    this._isOutside = this._axisManager.isOutside(input.axes);\n    this._moveDistance = this._axisManager.get(input.axes);\n  }\n\n  public change(input: InputType, event, offset: Axis, useDuration?: boolean) {\n    if (\n      this._isStopped ||\n      !this._interruptManager.isInterrupting() ||\n      this._axisManager.every(offset, (v) => v === 0)\n    ) {\n      return;\n    }\n    const nativeEvent = event.srcEvent ? event.srcEvent : event;\n    if (nativeEvent.__childrenAxesAlreadyChanged) {\n      return;\n    }\n    let depaPos: Axis = this._moveDistance || this._axisManager.get(input.axes);\n    let destPos: Axis;\n\n    // for outside logic\n    destPos = map(depaPos, (v, k) => v + (offset[k] || 0));\n    if (this._moveDistance) {\n      this._moveDistance = this._axisManager.map(\n        destPos,\n        (v, { circular, range }) =>\n          circular && (circular[0] || circular[1])\n            ? getCirculatedPos(v, range, circular as boolean[])\n            : v\n      );\n    }\n    // from outside to inside\n    if (\n      this._isOutside &&\n      this._axisManager.every(depaPos, (v, opt) => !isOutside(v, opt.range))\n    ) {\n      this._isOutside = false;\n    }\n    depaPos = this._atOutside(depaPos);\n    destPos = this._atOutside(destPos);\n\n    if (!this.options.nested || !this._isEndofAxis(offset, depaPos, destPos)) {\n      nativeEvent.__childrenAxesAlreadyChanged = true;\n    }\n\n    const changeOption: ChangeEventOption = {\n      input,\n      event,\n    };\n    if (useDuration) {\n      const duration = this._animationManager.getDuration(destPos, depaPos);\n      this._animationManager.animateTo(destPos, duration, changeOption);\n    } else {\n      const isCanceled = !this._eventManager.triggerChange(\n        destPos,\n        depaPos,\n        changeOption,\n        true\n      );\n      if (isCanceled) {\n        this._isStopped = true;\n        this._moveDistance = null;\n        this._animationManager.finish(false);\n      }\n    }\n  }\n\n  public release(\n    input: InputType,\n    event,\n    velocity: number[],\n    inputDuration?: number\n  ) {\n    if (\n      this._isStopped ||\n      !this._interruptManager.isInterrupting() ||\n      !this._moveDistance\n    ) {\n      return;\n    }\n    const nativeEvent = event.srcEvent ? event.srcEvent : event;\n    if (nativeEvent.__childrenAxesAlreadyReleased) {\n      velocity = velocity.map(() => 0);\n    }\n    const pos: Axis = this._axisManager.get(input.axes);\n    const depaPos: Axis = this._axisManager.get();\n    const displacement = this._animationManager.getDisplacement(velocity);\n    const offset = toAxis(input.axes, displacement);\n    let destPos: Axis = this._axisManager.get(\n      this._axisManager.map(offset, (v, opt, k) => {\n        if (opt.circular && (opt.circular[0] || opt.circular[1])) {\n          return pos[k] + v;\n        } else {\n          return getInsidePosition(\n            pos[k] + v,\n            opt.range,\n            opt.circular as boolean[],\n            opt.bounce as number[]\n          );\n        }\n      })\n    );\n    nativeEvent.__childrenAxesAlreadyReleased = true;\n    const duration = this._animationManager.getDuration(\n      destPos,\n      pos,\n      inputDuration\n    );\n\n    if (duration === 0) {\n      destPos = { ...depaPos };\n    }\n    // prepare params\n    const param: AnimationParam = {\n      depaPos,\n      destPos,\n      duration,\n      delta: this._axisManager.getDelta(depaPos, destPos),\n      inputEvent: event,\n      input,\n      isTrusted: true,\n    };\n    this._eventManager.triggerRelease(param);\n    this._moveDistance = null;\n\n    // to contol\n    const userWish = this._animationManager.getUserControl(param);\n    const isEqual = equal(userWish.destPos, depaPos);\n    const changeOption: ChangeEventOption = {\n      input,\n      event,\n    };\n    if (isEqual || userWish.duration === 0) {\n      if (!isEqual) {\n        this._eventManager.triggerChange(\n          userWish.destPos,\n          depaPos,\n          changeOption,\n          true\n        );\n      }\n      this._interruptManager.setInterrupt(false);\n      if (this._axisManager.isOutside()) {\n        this._animationManager.restore(changeOption);\n      } else {\n        this._eventManager.triggerFinish(true);\n      }\n    } else {\n      this._animationManager.animateTo(\n        userWish.destPos,\n        userWish.duration,\n        changeOption\n      );\n    }\n  }\n\n  // when move pointer is held in outside\n  private _atOutside(pos: Axis) {\n    if (this._isOutside) {\n      return this._axisManager.map(pos, (v, opt) => {\n        const tn = opt.range[0] - (opt.bounce[0] as number);\n        const tx = opt.range[1] + (opt.bounce[1] as number);\n        return v > tx ? tx : v < tn ? tn : v;\n      });\n    } else {\n      return this._axisManager.map(pos, (v, opt) => {\n        const min = opt.range[0];\n        const max = opt.range[1];\n        const out = opt.bounce;\n        const circular = opt.circular;\n\n        if (circular && (circular[0] || circular[1])) {\n          return v;\n        } else if (v < min) {\n          // left\n          return (\n            min - this._animationManager.interpolate(min - v, out[0] as number)\n          );\n        } else if (v > max) {\n          // right\n          return (\n            max + this._animationManager.interpolate(v - max, out[1] as number)\n          );\n        }\n        return v;\n      });\n    }\n  }\n\n  private _isEndofAxis(offset: Axis, depaPos: Axis, destPos: Axis) {\n    return this._axisManager.every(\n      depaPos,\n      (value, option, key) =>\n        offset[key] === 0 ||\n        (depaPos[key] === destPos[key] &&\n          isEndofBounce(\n            value,\n            option.range,\n            option.bounce as number[],\n            option.circular as boolean[]\n          ))\n    );\n  }\n}\n","import Component from \"@egjs/component\";\n\nimport { AnimationManager } from \"./AnimationManager\";\nimport { EventManager } from \"./EventManager\";\nimport { InterruptManager } from \"./InterruptManager\";\nimport { AxisManager, AxisOption, Axis } from \"./AxisManager\";\nimport { InputObserver } from \"./InputObserver\";\nimport {\n  TRANSFORM,\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n} from \"./const\";\nimport { InputType } from \"./inputType/InputType\";\nimport { AxesEvents, ObjectInterface, UpdateAnimationOption } from \"./types\";\n\nexport interface AxesOption {\n  easing?: (x: number) => number;\n  maximumDuration?: number;\n  minimumDuration?: number;\n  deceleration?: number;\n  interruptable?: boolean;\n  round?: number;\n  nested?: boolean;\n}\n\n/**\n * @typedef {Object} AxisOption The Axis information. The key of the axis specifies the name to use as the logical virtual coordinate system.\n * @ko 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.\n * @param {Number[]} [range] The coordinate of range <ko>좌표 범위</ko>\n * @param {Number} [range[0]=0] The coordinate of the minimum <ko>최소 좌표</ko>\n * @param {Number} [range[1]=0] The coordinate of the maximum <ko>최대 좌표</ko>\n * @param {Number[]} [bounce] The size of bouncing area. The coordinates can exceed the coordinate area as much as the bouncing area based on user action. If the coordinates does not exceed the bouncing area when an element is dragged, the coordinates where bouncing effects are applied are retuned back into the coordinate area<ko>바운스 영역의 크기. 사용자의 동작에 따라 좌표가 좌표 영역을 넘어 바운스 영역의 크기만큼 더 이동할 수 있다. 사용자가 끌어다 놓는 동작을 했을 때 좌표가 바운스 영역에 있으면, 바운스 효과가 적용된 좌표가 다시 좌표 영역 안으로 들어온다</ko>\n * @param {Number} [bounce[0]=0] The size of coordinate of the minimum area <ko>최소 좌표 바운스 영역의 크기</ko>\n * @param {Number} [bounce[1]=0] The size of coordinate of the maximum area <ko>최대 좌표 바운스 영역의 크기</ko>\n * @param {Boolean[]} [circular] Indicates whether a circular element is available. If it is set to \"true\" and an element is dragged outside the coordinate area, the element will appear on the other side.<ko>순환 여부. 'true'로 설정한 방향의 좌표 영역 밖으로 엘리먼트가 이동하면 반대 방향에서 엘리먼트가 나타난다</ko>\n * @param {Boolean} [circular[0]=false] Indicates whether to circulate to the coordinate of the minimum <ko>최소 좌표 방향의 순환 여부</ko>\n * @param {Boolean} [circular[1]=false] Indicates whether to circulate to the coordinate of the maximum <ko>최대 좌표 방향의 순환 여부</ko>\n **/\n\n/**\n * @typedef {Object} AxesOption The option object of the eg.Axes module\n * @ko eg.Axes 모듈의 옵션 객체\n * @param {Function} [easing=easing.easeOutCubic] The easing function to apply to an animation <ko>애니메이션에 적용할 easing 함수</ko>\n * @param {Number} [maximumDuration=Infinity] Maximum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최대 좌표 이동 시간</ko>\n * @param {Number} [minimumDuration=0] Minimum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최소 좌표 이동 시간</ko>\n * @param {Number} [deceleration=0.0006] Deceleration of the animation where acceleration is manually enabled by user. A higher value indicates shorter running time. <ko>사용자의 동작으로 가속도가 적용된 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다</ko>\n * @param {Boolean} [interruptable=true] Indicates whether an animation is interruptible.\n * - true: It can be paused or stopped by user action or the API.\n * - false: It cannot be paused or stopped by user action or the API while it is running.\n * <ko>진행 중인 애니메이션 중지 가능 여부.\n * - true: 사용자의 동작이나 API로 애니메이션을 중지할 수 있다.\n * - false: 애니메이션이 진행 중일 때는 사용자의 동작이나 API가 적용되지 않는다</ko>\n * @param {Number} [round=null] Rounding unit. For example, 0.1 rounds to 0.1 decimal point(6.1234 => 6.1), 5 rounds to 5 (93 => 95)\n * [Details](https://github.com/naver/egjs-axes/wiki/round-option)<ko>반올림 단위. 예를 들어 0.1 은 소숫점 0.1 까지 반올림(6.1234 => 6.1), 5 는 5 단위로 반올림(93 => 95).\n * [상세내용](https://github.com/naver/egjs-axes/wiki/round-option)</ko>\n * @param {Boolean} [nested=false] Whether the event propagates to other instances when the coordinates reach the end of the movable area <ko>좌표가 이동 가능한 영역의 끝까지 도달했을 때 다른 인스턴스들로의 이벤트 전파 여부</ko>\n **/\n\n/**\n * A module used to change the information of user action entered by various input devices such as touch screen or mouse into the logical virtual coordinates. You can easily create a UI that responds to user actions.\n * @ko 터치 입력 장치나 마우스와 같은 다양한 입력 장치를 통해 전달 받은 사용자의 동작을 논리적인 가상 좌표로 변경하는 모듈이다. 사용자 동작에 반응하는 UI를 손쉽게 만들수 있다.\n * @extends eg.Component\n *\n * @param {Object.<string, AxisOption>} axis Axis information managed by eg.Axes. The key of the axis specifies the name to use as the logical virtual coordinate system.  <ko>eg.Axes가 관리하는 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.</ko>\n * @param {AxesOption} [options={}] The option object of the eg.Axes module<ko>eg.Axes 모듈의 옵션 객체</ko>\n * @param {Object.<string, number>} [startPos=null] The coordinates to be moved when creating an instance. not triggering change event.<ko>인스턴스 생성시 이동할 좌표, change 이벤트는 발생하지 않음.</ko>\n *\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.3+ (except 3.x)\"}\n * @example\n * ```js\n * // 1. Initialize eg.Axes\n * const axes = new eg.Axes({\n *\tsomething1: {\n *\t\trange: [0, 150],\n *\t\tbounce: 50\n *\t},\n *\tsomething2: {\n *\t\trange: [0, 200],\n *\t\tbounce: 100\n *\t},\n *\tsomethingN: {\n *\t\trange: [1, 10],\n *\t}\n * }, {\n *  deceleration : 0.0024\n * });\n *\n * // 2. attach event handler\n * axes.on({\n *\t\"hold\" : function(evt) {\n *\t},\n *\t\"release\" : function(evt) {\n *\t},\n *\t\"animationStart\" : function(evt) {\n *\t},\n *\t\"animationEnd\" : function(evt) {\n *\t},\n *\t\"change\" : function(evt) {\n *\t}\n * });\n *\n * // 3. Initialize inputTypes\n * const panInputArea = new eg.Axes.PanInput(\"#area\", {\n *\tscale: [0.5, 1]\n * });\n * const panInputHmove = new eg.Axes.PanInput(\"#hmove\");\n * const panInputVmove = new eg.Axes.PanInput(\"#vmove\");\n * const pinchInputArea = new eg.Axes.PinchInput(\"#area\", {\n *\tscale: 1.5\n * });\n *\n * // 4. Connect eg.Axes and InputTypes\n * // [PanInput] When the mouse or touchscreen is down and moved.\n * // Connect the 'something2' axis to the mouse or touchscreen x position and\n * // connect the 'somethingN' axis to the mouse or touchscreen y position.\n * axes.connect([\"something2\", \"somethingN\"], panInputArea); // or axes.connect(\"something2 somethingN\", panInputArea);\n *\n * // Connect only one 'something1' axis to the mouse or touchscreen x position.\n * axes.connect([\"something1\"], panInputHmove); // or axes.connect(\"something1\", panInputHmove);\n *\n * // Connect only one 'something2' axis to the mouse or touchscreen y position.\n * axes.connect([\"\", \"something2\"], panInputVmove); // or axes.connect(\" something2\", panInputVmove);\n *\n * // [PinchInput] Connect 'something2' axis when two pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * axes.connect(\"something2\", pinchInputArea);\n * ```\n */\nclass Axes extends Component<AxesEvents> {\n  /**\n   * @name VERSION\n   * @desc Version info string\n   * @ko 버전정보 문자열\n   *\n   * @constant\n   * @type {String}\n   * @example\n   * ```js\n   * eg.Axes.VERSION;  // ex) 3.3.3\n   * ```\n   */\n  public static VERSION = \"#__VERSION__#\";\n  /* eslint-disable */\n  // for tree shaking\n  public static PanInput;\n  public static PinchInput;\n  public static WheelInput;\n  public static MoveKeyInput;\n  public static RotatePanInput;\n  /* eslint-enable */\n\n  /**\n   * @name TRANSFORM\n   * @desc Returns the transform attribute with CSS vendor prefixes.\n   * @ko CSS vendor prefixes를 붙인 transform 속성을 반환한다.\n   *\n   * @constant\n   * @type {String}\n   * @example\n   * ```js\n   * eg.Axes.TRANSFORM; // \"transform\" or \"webkitTransform\"\n   * ```\n   */\n  public static TRANSFORM = TRANSFORM;\n  /**\n   * @name DIRECTION_NONE\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_NONE = DIRECTION_NONE;\n  /**\n   * @name DIRECTION_LEFT\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_LEFT = DIRECTION_LEFT;\n  /**\n   * @name DIRECTION_RIGHT\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_RIGHT = DIRECTION_RIGHT;\n  /**\n   * @name DIRECTION_UP\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_UP = DIRECTION_UP;\n  /**\n   * @name DIRECTION_DOWN\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_DOWN = DIRECTION_DOWN;\n  /**\n   * @name DIRECTION_HORIZONTAL\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  /**\n   * @name DIRECTION_VERTICAL\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  /**\n   * @name DIRECTION_ALL\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_ALL = DIRECTION_ALL;\n\n  public options: AxesOption;\n  public eventManager: EventManager;\n  public axisManager: AxisManager;\n  public interruptManager: InterruptManager;\n  public animationManager: AnimationManager;\n  public inputObserver: InputObserver;\n  private _inputs: InputType[] = [];\n\n  /**\n   *\n   */\n  public constructor(\n    public axis: ObjectInterface<AxisOption> = {},\n    options: AxesOption = {},\n    startPos: Axis = null\n  ) {\n    super();\n    this.options = {\n      ...{\n        easing: (x) => {\n          return 1 - Math.pow(1 - x, 3);\n        },\n        interruptable: true,\n        maximumDuration: Infinity,\n        minimumDuration: 0,\n        deceleration: 0.0006,\n        round: null,\n        nested: false,\n      },\n      ...options,\n    };\n\n    this.interruptManager = new InterruptManager(this.options);\n    this.axisManager = new AxisManager(this.axis);\n    this.eventManager = new EventManager(this);\n    this.animationManager = new AnimationManager(this);\n    this.inputObserver = new InputObserver(this);\n    this.eventManager.setAnimationManager(this.animationManager);\n    if (startPos) {\n      this.eventManager.triggerChange(startPos);\n    }\n  }\n\n  /**\n   * Connect the axis of eg.Axes to the inputType.\n   * @ko eg.Axes의 축과 inputType을 연결한다\n   * @param {(String[]|String)} axes The name of the axis to associate with inputType <ko>inputType과 연결할 축의 이름</ko>\n   * @param {Object} inputType The inputType instance to associate with the axis of eg.Axes <ko>eg.Axes의 축과 연결할 inputType 인스턴스</ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   }\n   * });\n   *\n   * axes.connect(\"x\", new eg.Axes.PanInput(\"#area1\"))\n   *    .connect(\"x xOther\", new eg.Axes.PanInput(\"#area2\"))\n   *    .connect(\" xOther\", new eg.Axes.PanInput(\"#area3\"))\n   *    .connect([\"x\"], new eg.Axes.PanInput(\"#area4\"))\n   *    .connect([\"xOther\", \"x\"], new eg.Axes.PanInput(\"#area5\"))\n   *    .connect([\"\", \"xOther\"], new eg.Axes.PanInput(\"#area6\"));\n   * ```\n   */\n  public connect(axes: string[] | string, inputType: InputType) {\n    let mapped: string[];\n    if (typeof axes === \"string\") {\n      mapped = axes.split(\" \");\n    } else {\n      mapped = axes.concat();\n    }\n\n    // check same instance\n    if (~this._inputs.indexOf(inputType)) {\n      this.disconnect(inputType);\n    }\n\n    inputType.mapAxes(mapped);\n    inputType.connect(this.inputObserver);\n    this._inputs.push(inputType);\n    return this;\n  }\n\n  /**\n   * Disconnect the axis of eg.Axes from the inputType.\n   * @ko eg.Axes의 축과 inputType의 연결을 끊는다.\n   * @param {Object} [inputType] An inputType instance associated with the axis of eg.Axes <ko>eg.Axes의 축과 연결한 inputType 인스턴스</ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   }\n   * });\n   *\n   * const input1 = new eg.Axes.PanInput(\"#area1\");\n   * const input2 = new eg.Axes.PanInput(\"#area2\");\n   * const input3 = new eg.Axes.PanInput(\"#area3\");\n   *\n   * axes.connect(\"x\", input1);\n   *    .connect(\"x xOther\", input2)\n   *    .connect([\"xOther\", \"x\"], input3);\n   *\n   * axes.disconnect(input1); // disconnects input1\n   * axes.disconnect(); // disconnects all of them\n   * ```\n   */\n  public disconnect(inputType?: InputType) {\n    if (inputType) {\n      const index = this._inputs.indexOf(inputType);\n\n      if (index >= 0) {\n        this._inputs[index].disconnect();\n        this._inputs.splice(index, 1);\n      }\n    } else {\n      this._inputs.forEach((v) => v.disconnect());\n      this._inputs = [];\n    }\n    return this;\n  }\n\n  /**\n   * Returns the current position of the coordinates.\n   * @ko 좌표의 현재 위치를 반환한다\n   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>\n   * @return {Object.<string, number>} Axis coordinate information <ko>축 좌표 정보</ko>\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   },\n   * \t \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.get(); // {\"x\": 0, \"xOther\": -100, \"zoom\": 50}\n   * axes.get([\"x\", \"zoom\"]); // {\"x\": 0, \"zoom\": 50}\n   * ```\n   */\n  public get(axes?: string[]) {\n    return this.axisManager.get(axes);\n  }\n\n  /**\n   * Moves an axis to specific coordinates.\n   * @ko 좌표를 이동한다.\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   },\n   * \t \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.setTo({\"x\": 30, \"zoom\": 60});\n   * axes.get(); // {\"x\": 30, \"xOther\": -100, \"zoom\": 60}\n   *\n   * axes.setTo({\"x\": 100, \"xOther\": 60}, 1000); // animatation\n   *\n   * // after 1000 ms\n   * axes.get(); // {\"x\": 100, \"xOther\": 60, \"zoom\": 60}\n   * ```\n   */\n  public setTo(pos: Axis, duration = 0) {\n    this.animationManager.setTo(pos, duration);\n    return this;\n  }\n\n  /**\n   * Moves an axis from the current coordinates to specific coordinates.\n   * @ko 현재 좌표를 기준으로 좌표를 이동한다.\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   },\n   * \t \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.setBy({\"x\": 30, \"zoom\": 10});\n   * axes.get(); // {\"x\": 30, \"xOther\": -100, \"zoom\": 60}\n   *\n   * axes.setBy({\"x\": 70, \"xOther\": 60}, 1000); // animatation\n   *\n   * // after 1000 ms\n   * axes.get(); // {\"x\": 100, \"xOther\": -40, \"zoom\": 60}\n   * ```\n   */\n  public setBy(pos: Axis, duration = 0) {\n    this.animationManager.setBy(pos, duration);\n    return this;\n  }\n\n  /**\n   * Stop an animation in progress.\n   * @ko 재생 중인 애니메이션을 정지한다.\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   * });\n   *\n   * axes.setTo({\"x\": 10}, 1000); // start animatation\n   *\n   * // after 500 ms\n   * axes.stopAnimation(); // stop animation during movement.\n   * ```\n   */\n  public stopAnimation() {\n    this.animationManager.stopAnimation();\n    return this;\n  }\n\n  /**\n   * Change the destination of an animation in progress.\n   * @ko 재생 중인 애니메이션의 목적지와 진행 시간을 변경한다.\n   * @param {UpdateAnimationOption} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 200]\n   *   },\n   *   \"y\": {\n   *      range: [0, 200]\n   *   }\n   * });\n   *\n   * axes.setTo({\"x\": 50, \"y\": 50}, 1000); // trigger animation by setTo\n   *\n   * // after 500 ms\n   * axes.updateAnimation({destPos: {\"x\": 100, \"y\": 100}}); // animation will end after 500 ms, at {\"x\": 100, \"y\": 100}\n   *\n   * // after 500 ms\n   * axes.setTo({\"x\": 50, \"y\": 50}, 1000); // trigger animation by setTo\n   *\n   * // after 700 ms\n   * axes.updateAnimation({destPos: {\"x\": 100, \"y\": 100}, duration: 1500, restart: true}); // this works same as axes.setTo({\"x\": 100, \"y\": 100}, 800) since restart is true.\n   * ```\n   */\n  public updateAnimation(options: UpdateAnimationOption) {\n    this.animationManager.updateAnimation(options);\n    return this;\n  }\n\n  /**\n   * Returns whether there is a coordinate in the bounce area of ​​the target axis.\n   * @ko 대상 축 중 bounce영역에 좌표가 존재하는지를 반환한다\n   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>\n   * @return {Boolen} Whether the bounce area exists. <ko>bounce 영역 존재 여부</ko>\n   * @example\n   * ```js\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   },\n   * \t \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.isBounceArea([\"x\"]);\n   * axes.isBounceArea([\"x\", \"zoom\"]);\n   * axes.isBounceArea();\n   * ```\n   */\n  public isBounceArea(axes?: string[]) {\n    return this.axisManager.isOutside(axes);\n  }\n\n  /**\n   * Destroys properties, and events used in a module and disconnect all connections to inputTypes.\n   * @ko 모듈에 사용한 속성, 이벤트를 해제한다. 모든 inputType과의 연결을 끊는다.\n   */\n  public destroy() {\n    this.disconnect();\n    this.eventManager.destroy();\n  }\n}\n\nexport default Axes;\n","import { ExtendedEvent } from \"../types\";\nimport Axes from \"../Axes\";\nimport { getAngle } from \"../utils\";\n\nimport { toAxis } from \"./InputType\";\nimport { PanInput, PanInputOption } from \"./PanInput\";\n\n/**\n * A module that passes the angle moved by touch to Axes and uses one axis of rotation.\n * [Details](https://github.com/naver/egjs-axes/wiki/RotatePanInput)\n * @ko 터치에 의해 움직인 각도를 Axes 에 전달하며 1개의 회전축만 사용한다.\n * [상세내용](https://github.com/naver/egjs-axes/wiki/RotatePanInput-%7C-%ED%95%9C%EA%B5%AD%EC%96%B4)\n *\n * @example\n * ```js\n * const input = new eg.Axes.RotatePanInput(\"#area\");\n *\n * var axes = new eg.Axes({\n *\t// property name('angle') could be anything you want (eg. x, y, z...)\n * \tangle: {\n * \t\trange: [-180, 180] // from -180deg to 180deg\n * \t}\n * });\n *\n * axes.connect(\"angle\", input)\n * ```\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.RotatePanInput module <ko>eg.Axes.RotatePanInput 모듈을 사용할 엘리먼트</ko>\n * @param {PanInputOption} [options] The option object of the eg.Axes.PanInput module<ko>eg.Axes.PanInput 모듈의 옵션 객체</ko>\n * @extends PanInput\n */\nexport class RotatePanInput extends PanInput {\n  private _rotateOrigin: number[];\n  private _prevAngle: number;\n  private _prevQuadrant: number = null;\n  private _lastDiff = 0;\n  private _coefficientForDistanceToAngle: number;\n\n  /**\n   *\n   */\n  public constructor(el: string | HTMLElement, options?: PanInputOption) {\n    super(el, options);\n  }\n\n  public mapAxes(axes: string[]) {\n    this._direction = Axes.DIRECTION_ALL;\n    this.axes = axes;\n  }\n\n  protected _onPanstart(event: MouseEvent) {\n    const activeEvent = this._activeEvent;\n    const panEvent = activeEvent.onEventStart(event, this.options.inputButton);\n    if (!panEvent || !this.isEnabled()) {\n      return;\n    }\n\n    const rect = this.element.getBoundingClientRect();\n\n    this._observer.hold(this, panEvent);\n    this._attachWindowEvent(activeEvent);\n    // TODO: how to do if element is ellipse not circle.\n    this._coefficientForDistanceToAngle = 360 / (rect.width * Math.PI); // from 2*pi*r * x / 360\n    // TODO: provide a way to set origin like https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n    this._rotateOrigin = [\n      rect.left + (rect.width - 1) / 2,\n      rect.top + (rect.height - 1) / 2,\n    ];\n\n    // init angle.\n    this._prevAngle = null;\n\n    this._triggerChange(panEvent);\n    activeEvent.prevEvent = panEvent;\n  }\n\n  protected _onPanmove(event: MouseEvent) {\n    const activeEvent = this._activeEvent;\n    const panEvent = activeEvent.onEventMove(event, this.options.inputButton);\n    if (!panEvent || !this.isEnabled()) {\n      return;\n    }\n\n    if (panEvent.srcEvent.cancelable !== false) {\n      panEvent.srcEvent.preventDefault();\n    }\n    panEvent.srcEvent.stopPropagation();\n    this._triggerChange(panEvent);\n    activeEvent.prevEvent = panEvent;\n  }\n\n  protected _onPanend(event: MouseEvent) {\n    const activeEvent = this._activeEvent;\n    activeEvent.onEventEnd(event);\n    if (!this.isEnabled()) {\n      return;\n    }\n    const prevEvent = activeEvent.prevEvent;\n    this._triggerChange(prevEvent);\n    const vx = prevEvent.velocityX;\n    const vy = prevEvent.velocityY;\n    const velocity =\n      Math.sqrt(vx * vx + vy * vy) * (this._lastDiff > 0 ? -1 : 1); // clockwise\n    this._observer.release(this, prevEvent, [\n      velocity * this._coefficientForDistanceToAngle,\n    ]);\n    activeEvent.onRelease();\n    this._detachWindowEvent(activeEvent);\n  }\n\n  private _triggerChange(event: ExtendedEvent) {\n    const { x, y } = this._getPosFromOrigin(event.center.x, event.center.y);\n    const angle = getAngle(x, y);\n    const positiveAngle = angle < 0 ? 360 + angle : angle;\n    const quadrant = this._getQuadrant(event.center.x, event.center.y);\n    const diff = this._getDifference(\n      this._prevAngle,\n      positiveAngle,\n      this._prevQuadrant,\n      quadrant\n    );\n\n    this._prevAngle = positiveAngle;\n    this._prevQuadrant = quadrant;\n\n    if (diff === 0) {\n      return;\n    }\n\n    this._lastDiff = diff;\n    this._observer.change(this, event, toAxis(this.axes, [-diff])); // minus for clockwise\n  }\n\n  private _getDifference(\n    prevAngle: number,\n    angle: number,\n    prevQuadrant: number,\n    quadrant: number\n  ) {\n    let diff: number;\n\n    if (prevAngle === null) {\n      diff = 0;\n    } else if (prevQuadrant === 1 && quadrant === 4) {\n      diff = -prevAngle - (360 - angle);\n    } else if (prevQuadrant === 4 && quadrant === 1) {\n      diff = 360 - prevAngle + angle;\n    } else {\n      diff = angle - prevAngle;\n    }\n\n    return diff;\n  }\n\n  private _getPosFromOrigin(posX: number, posY: number) {\n    return {\n      x: posX - this._rotateOrigin[0],\n      y: this._rotateOrigin[1] - posY,\n    };\n  }\n\n  private _getQuadrant(posX: number, posY: number) {\n    /**\n     * Quadrant\n     *       y(+)\n     *       |\n     *   2   |    1\n     * --------------->x(+)\n     *   3   |    4\n     *       |\n     */\n    const { x, y } = this._getPosFromOrigin(posX, posY);\n    let q = 0;\n\n    if (x >= 0 && y >= 0) {\n      q = 1;\n    } else if (x < 0 && y >= 0) {\n      q = 2;\n    } else if (x < 0 && y < 0) {\n      q = 3;\n    } else if (x >= 0 && y < 0) {\n      q = 4;\n    }\n    return q;\n  }\n}\n","import { $, setCssProps } from \"../utils\";\nimport { ActiveEvent, InputEventType } from \"../types\";\nimport { PREVENT_SCROLL_CSSPROPS } from \"../const\";\n\nimport {\n  toAxis,\n  convertInputType,\n  InputType,\n  InputTypeObserver,\n} from \"./InputType\";\n\nexport interface PinchInputOption {\n  scale?: number;\n  threshold?: number;\n  inputType?: string[];\n}\n\n/**\n * @typedef {Object} PinchInputOption The option object of the eg.Axes.PinchInput module\n * @ko eg.Axes.PinchInput 모듈의 옵션 객체\n * @param {Number} [scale=1] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @param {Number} [threshold=0] Minimal scale before recognizing <ko>사용자의 Pinch 동작을 인식하기 위해산 최소한의 배율</ko>\n **/\n\n/**\n * A module that passes the amount of change to eg.Axes when two pointers are moving toward (zoom-in) or away from each other (zoom-out). use one axis.\n * @ko 2개의 pointer를 이용하여 zoom-in하거나 zoom-out 하는 동작의 변화량을 eg.Axes에 전달하는 모듈. 한 개 의 축을 사용한다.\n * @example\n * ```js\n * const pinch = new eg.Axes.PinchInput(\"#area\", {\n * \t\tscale: 1\n * });\n *\n * // Connect 'something' axis when two pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * axes.connect(\"something\", pinch);\n * ```\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.PinchInput module <ko>eg.Axes.PinchInput 모듈을 사용할 엘리먼트</ko>\n * @param {PinchInputOption} [options] The option object of the eg.Axes.PinchInput module<ko>eg.Axes.PinchInput 모듈의 옵션 객체</ko>\n */\nexport class PinchInput implements InputType {\n  public options: PinchInputOption;\n  public axes: string[] = [];\n  public element: HTMLElement = null;\n  private _observer: InputTypeObserver;\n  private _pinchFlag = false;\n  private _enabled = false;\n  private _originalCssProps: { [key: string]: string };\n  private _activeEvent: ActiveEvent = null;\n  private _baseValue: number;\n\n  /**\n   *\n   */\n  public constructor(el: string | HTMLElement, options?: PinchInputOption) {\n    this.element = $(el);\n    this.options = {\n      scale: 1,\n      threshold: 0,\n      inputType: [\"touch\", \"pointer\"],\n      ...options,\n    };\n    this._onPinchStart = this._onPinchStart.bind(this);\n    this._onPinchMove = this._onPinchMove.bind(this);\n    this._onPinchEnd = this._onPinchEnd.bind(this);\n  }\n\n  public mapAxes(axes: string[]) {\n    this.axes = axes;\n  }\n\n  public connect(observer: InputTypeObserver): InputType {\n    if (this._activeEvent) {\n      this._detachEvent();\n    }\n    this._attachEvent(observer);\n    this._originalCssProps = setCssProps(this.element);\n    return this;\n  }\n\n  public disconnect() {\n    this._detachEvent();\n    if (this._originalCssProps !== PREVENT_SCROLL_CSSPROPS) {\n      setCssProps(this.element, this._originalCssProps);\n    }\n    return this;\n  }\n\n  /**\n   * Destroys elements, properties, and events used in a module.\n   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n   */\n  public destroy() {\n    this.disconnect();\n    this.element = null;\n  }\n\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @return {PinchInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enable() {\n    this._enabled = true;\n    return this;\n  }\n\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @return {PinchInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disable() {\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  private _onPinchStart(event: InputEventType) {\n    const activeEvent = this._activeEvent;\n    const pinchEvent = activeEvent.onEventStart(event);\n    if (!pinchEvent || !this._enabled || activeEvent.getTouches(event) !== 2) {\n      return;\n    }\n\n    this._baseValue = this._observer.get(this)[this.axes[0]];\n    this._observer.hold(this, event);\n    this._pinchFlag = true;\n    activeEvent.prevEvent = pinchEvent;\n  }\n\n  private _onPinchMove(event: InputEventType) {\n    const activeEvent = this._activeEvent;\n    const pinchEvent = activeEvent.onEventMove(event);\n    if (\n      !pinchEvent ||\n      !this._pinchFlag ||\n      !this._enabled ||\n      activeEvent.getTouches(event) !== 2\n    ) {\n      return;\n    }\n\n    const offset = this._getOffset(\n      pinchEvent.scale,\n      activeEvent.prevEvent.scale\n    );\n    this._observer.change(this, event, toAxis(this.axes, [offset]));\n    activeEvent.prevEvent = pinchEvent;\n  }\n\n  private _onPinchEnd(event: InputEventType) {\n    const activeEvent = this._activeEvent;\n    activeEvent.onEventEnd(event);\n    if (\n      !this._pinchFlag ||\n      !this._enabled ||\n      activeEvent.getTouches(event) >= 2\n    ) {\n      return;\n    }\n\n    this._observer.release(this, event, [0], 0);\n    activeEvent.onRelease();\n    this._baseValue = null;\n    this._pinchFlag = false;\n  }\n\n  private _attachEvent(observer: InputTypeObserver) {\n    const activeEvent = convertInputType(this.options.inputType);\n    if (!activeEvent) {\n      throw new Error(\n        \"There is currently no inputType available for current device. There must be at least one available inputType.\"\n      );\n    }\n    this._observer = observer;\n    this._enabled = true;\n    this._activeEvent = activeEvent;\n    activeEvent?.start.forEach((event) => {\n      this.element.addEventListener(event, this._onPinchStart, false);\n    });\n    activeEvent?.move.forEach((event) => {\n      this.element.addEventListener(event, this._onPinchMove, false);\n    });\n    activeEvent?.end.forEach((event) => {\n      this.element.addEventListener(event, this._onPinchEnd, false);\n    });\n  }\n\n  private _detachEvent() {\n    const activeEvent = this._activeEvent;\n    activeEvent?.start.forEach((event) => {\n      this.element.removeEventListener(event, this._onPinchStart, false);\n    });\n    activeEvent?.move.forEach((event) => {\n      this.element.removeEventListener(event, this._onPinchMove, false);\n    });\n    activeEvent?.end.forEach((event) => {\n      this.element.removeEventListener(event, this._onPinchEnd, false);\n    });\n    this._enabled = false;\n    this._observer = null;\n  }\n\n  private _getOffset(pinchScale: number, prev: number = 1): number {\n    return this._baseValue * (pinchScale - prev) * this.options.scale;\n  }\n}\n","import { $ } from \"../utils\";\n\nimport { toAxis, InputType, InputTypeObserver } from \"./InputType\";\n\nexport interface WheelInputOption {\n  scale?: number;\n  releaseDelay?: number;\n  useNormalized?: boolean;\n}\n\n/**\n * @typedef {Object} WheelInputOption The option object of the eg.Axes.WheelInput module\n * @ko eg.Axes.WheelInput 모듈의 옵션 객체\n * @param {Number} [scale=1] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @param {Number} [releaseDelay=300] Millisecond that trigger release event after last input<ko>마지막 입력 이후 release 이벤트가 트리거되기까지의 밀리초</ko>\n **/\n\n/**\n * A module that passes the amount of change to eg.Axes when the mouse wheel is moved. use one axis.\n * @ko 마우스 휠이 움직일때의 변화량을 eg.Axes에 전달하는 모듈. 한 개 의 축을 사용한다.\n *\n * @example\n * ```js\n * const wheel = new eg.Axes.WheelInput(\"#area\", {\n * \t\tscale: 1\n * });\n *\n * // Connect 'something' axis when the mousewheel is moved.\n * axes.connect(\"something\", wheel);\n * ```\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.WheelInput module <ko>eg.Axes.WheelInput 모듈을 사용할 엘리먼트</ko>\n * @param {WheelInputOption} [options] The option object of the eg.Axes.WheelInput module<ko>eg.Axes.WheelInput 모듈의 옵션 객체</ko>\n */\nexport class WheelInput implements InputType {\n  public options: WheelInputOption;\n  public axes: string[] = [];\n  public element: HTMLElement = null;\n  private _observer: InputTypeObserver;\n  private _enabled = false;\n  private _holding = false;\n  private _timer: NodeJS.Timeout = null;\n\n  /**\n   *\n   */\n  public constructor(el, options?: WheelInputOption) {\n    this.element = $(el);\n    this.options = {\n      ...{\n        scale: 1,\n        releaseDelay: 300,\n        useNormalized: true,\n      },\n      ...options,\n    };\n    this._onWheel = this._onWheel.bind(this);\n  }\n\n  public mapAxes(axes: string[]) {\n    this.axes = axes;\n  }\n\n  public connect(observer: InputTypeObserver): InputType {\n    this._detachEvent();\n    this._attachEvent(observer);\n    return this;\n  }\n\n  public disconnect() {\n    this._detachEvent();\n    return this;\n  }\n\n  /**\n   * Destroys elements, properties, and events used in a module.\n   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n   */\n  public destroy() {\n    this.disconnect();\n    this.element = null;\n  }\n\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @return {WheelInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enable() {\n    this._enabled = true;\n    return this;\n  }\n\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @return {WheelInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disable() {\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  private _onWheel(event: WheelEvent) {\n    if (!this._enabled) {\n      return;\n    }\n    event.preventDefault();\n\n    if (event.deltaY === 0) {\n      return;\n    }\n\n    if (!this._holding) {\n      this._observer.hold(this, event);\n      this._holding = true;\n    }\n    const offset =\n      (event.deltaY > 0 ? -1 : 1) *\n      this.options.scale *\n      (this.options.useNormalized ? 1 : Math.abs(event.deltaY));\n    this._observer.change(this, event, toAxis(this.axes, [offset]), true);\n    clearTimeout(this._timer);\n\n    this._timer = setTimeout(() => {\n      if (this._holding) {\n        this._holding = false;\n        this._observer.release(this, event, [0]);\n      }\n    }, this.options.releaseDelay);\n  }\n\n  private _attachEvent(observer: InputTypeObserver) {\n    this._observer = observer;\n    this.element.addEventListener(\"wheel\", this._onWheel);\n    this._enabled = true;\n  }\n\n  private _detachEvent() {\n    this.element.removeEventListener(\"wheel\", this._onWheel);\n    this._enabled = false;\n    this._observer = null;\n\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  }\n}\n","import { $ } from \"../utils\";\n\nimport { toAxis, InputType, InputTypeObserver } from \"./InputType\";\n\nexport const KEY_LEFT_ARROW = 37;\nexport const KEY_A = 65;\nexport const KEY_UP_ARROW = 38;\nexport const KEY_W = 87;\nexport const KEY_RIGHT_ARROW = 39;\nexport const KEY_D = 68;\nexport const KEY_DOWN_ARROW = 40;\nexport const KEY_S = 83;\n\n/* eslint-disable */\nconst DIRECTION_REVERSE = -1;\nconst DIRECTION_FORWARD = 1;\nconst DIRECTION_HORIZONTAL = -1;\nconst DIRECTION_VERTICAL = 1;\nconst DELAY = 80;\n/* eslint-enable */\n\nexport interface MoveKeyInputOption {\n  scale?: number[];\n}\n\n/**\n * @typedef {Object} MoveKeyInputOption The option object of the eg.Axes.MoveKeyInput module\n * @ko eg.Axes.MoveKeyInput 모듈의 옵션 객체\n * @param {Array<Number>} [scale] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @param {Number} [scale[0]=1] Coordinate scale for the first axis<ko>첫번째 축의 배율</ko>\n * @param {Number} [scale[1]=1] Coordinate scale for the decond axis<ko>두번째 축의 배율</ko>\n **/\n\n/**\n * A module that passes the amount of change to eg.Axes when the move key stroke is occured. use two axis.\n * @ko 이동키 입력이 발생했을 때의 변화량을 eg.Axes에 전달하는 모듈. 두 개 의 축을 사용한다.\n *\n * @example\n * ```js\n * const moveKey = new eg.Axes.MoveKeyInput(\"#area\", {\n * \t\tscale: [1, 1]\n * });\n *\n * // Connect 'x', 'y' axes when the moveKey is pressed.\n * axes.connect([\"x\", \"y\"], moveKey);\n * ```\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.MoveKeyInput module <ko>eg.Axes.MoveKeyInput 모듈을 사용할 엘리먼트</ko>\n * @param {MoveKeyInputOption} [options] The option object of the eg.Axes.MoveKeyInput module<ko>eg.Axes.MoveKeyInput 모듈의 옵션 객체</ko>\n */\nexport class MoveKeyInput implements InputType {\n  public options: MoveKeyInputOption;\n  public axes: string[] = [];\n  public element: HTMLElement = null;\n  private _observer: InputTypeObserver;\n  private _enabled = false;\n  private _holding = false;\n  private _timer: NodeJS.Timeout = null;\n\n  /**\n   *\n   */\n  public constructor(el, options?: MoveKeyInputOption) {\n    this.element = $(el);\n    this.options = {\n      ...{\n        scale: [1, 1],\n      },\n      ...options,\n    };\n    this._onKeydown = this._onKeydown.bind(this);\n    this._onKeyup = this._onKeyup.bind(this);\n  }\n\n  public mapAxes(axes: string[]) {\n    this.axes = axes;\n  }\n\n  public connect(observer: InputTypeObserver): InputType {\n    this._detachEvent();\n\n    // add tabindex=\"0\" to the container for making it focusable\n    if (this.element.getAttribute(\"tabindex\") !== \"0\") {\n      this.element.setAttribute(\"tabindex\", \"0\");\n    }\n\n    this._attachEvent(observer);\n    return this;\n  }\n\n  public disconnect() {\n    this._detachEvent();\n    return this;\n  }\n\n  /**\n   * Destroys elements, properties, and events used in a module.\n   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n   */\n  public destroy() {\n    this.disconnect();\n    this.element = null;\n  }\n\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @return {MoveKeyInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enable() {\n    this._enabled = true;\n    return this;\n  }\n\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @return {MoveKeyInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disable() {\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  private _onKeydown(event: KeyboardEvent) {\n    if (!this._enabled) {\n      return;\n    }\n\n    let isMoveKey = true;\n    let direction = DIRECTION_FORWARD;\n    let move = DIRECTION_HORIZONTAL;\n\n    switch (event.keyCode) {\n      case KEY_LEFT_ARROW:\n      case KEY_A:\n        direction = DIRECTION_REVERSE;\n        break;\n      case KEY_RIGHT_ARROW:\n      case KEY_D:\n        break;\n      case KEY_DOWN_ARROW:\n      case KEY_S:\n        direction = DIRECTION_REVERSE;\n        move = DIRECTION_VERTICAL;\n        break;\n      case KEY_UP_ARROW:\n      case KEY_W:\n        move = DIRECTION_VERTICAL;\n        break;\n      default:\n        isMoveKey = false;\n    }\n    if (\n      (move === DIRECTION_HORIZONTAL && !this.axes[0]) ||\n      (move === DIRECTION_VERTICAL && !this.axes[1])\n    ) {\n      isMoveKey = false;\n    }\n    if (!isMoveKey) {\n      return;\n    }\n    event.preventDefault();\n    const offsets =\n      move === DIRECTION_HORIZONTAL\n        ? [+this.options.scale[0] * direction, 0]\n        : [0, +this.options.scale[1] * direction];\n\n    if (!this._holding) {\n      this._observer.hold(this, event);\n      this._holding = true;\n    }\n    clearTimeout(this._timer);\n    this._observer.change(this, event, toAxis(this.axes, offsets));\n  }\n\n  private _onKeyup(event: KeyboardEvent) {\n    if (!this._holding) {\n      return;\n    }\n    clearTimeout(this._timer);\n    this._timer = setTimeout(() => {\n      this._observer.release(this, event, [0, 0]);\n      this._holding = false;\n    }, DELAY);\n  }\n\n  private _attachEvent(observer: InputTypeObserver) {\n    this._observer = observer;\n    this.element.addEventListener(\"keydown\", this._onKeydown, false);\n    this.element.addEventListener(\"keypress\", this._onKeydown, false);\n    this.element.addEventListener(\"keyup\", this._onKeyup, false);\n    this._enabled = true;\n  }\n\n  private _detachEvent() {\n    this.element.removeEventListener(\"keydown\", this._onKeydown, false);\n    this.element.removeEventListener(\"keypress\", this._onKeydown, false);\n    this.element.removeEventListener(\"keyup\", this._onKeyup, false);\n    this._enabled = false;\n    this._observer = null;\n  }\n}\n","import Axes from \"./Axes\";\nimport { PanInput } from \"./inputType/PanInput\";\nimport { RotatePanInput } from \"./inputType/RotatePanInput\";\nimport { PinchInput } from \"./inputType/PinchInput\";\nimport { WheelInput } from \"./inputType/WheelInput\";\nimport { MoveKeyInput } from \"./inputType/MoveKeyInput\";\n\nAxes.PanInput = PanInput;\nAxes.RotatePanInput = RotatePanInput;\nAxes.PinchInput = PinchInput;\nAxes.WheelInput = WheelInput;\nAxes.MoveKeyInput = MoveKeyInput;\n\nexport default Axes;\n"],"names":["getInsidePosition","destPos","range","circular","bounce","toDestPos","targetRange","Math","max","min","isOutside","pos","isCircularable","getCirculatedPos","toPos","length","win","window","navigator","userAgent","toArray","nodes","el","i","len","push","keyInfo_1","oldraf_1","MOUSE_LEFT","MOUSE_RIGHT","MOUSE_MIDDLE","IS_IOS_SAFARI","browser","name","TRANSFORM","document","bodyStyle","head","getElementsByTagName","style","target","PREVENT_SCROLL_CSSPROPS","$","param","multi","dummy","match","createElement","innerHTML","childNodes","querySelectorAll","undefined","nodeName","nodeType","jQuery","constructor","prototype","jquery","get","Array","isArray","map","v","raf","requestAnimationFrame","webkitRequestAnimationFrame","caf","cancelAnimationFrame","webkitCancelAnimationFrame","callback","key","timestamp","setTimeout","performance","now","Date","getTime","clearTimeout","obj","tranformed","k","filter","filtered","every","equal","base","roundNumber","num","roundUnit","roundNumFunc","getRoundFunc","roundNumbers","value","getDecimalPlace","val","isFinite","indexOf","p","e","round","getAngle","posX","posY","atan2","PI","setCssProps","element","originalCssProps","newCssProps_1","oldCssProps","Object","keys","forEach","prop","clamp","toAxis","source","offset","reduce","acc","convertInputType","inputType","hasTouch","hasMouse","hasPointer","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","PointerEventInput","TouchMouseEventInput","TouchEventInput","MouseEventInput","useDirection","checkType","direction","userDirection","pow","n","_a","options","interruptManager","eventManager","axisManager","_options","animationEnd","this","bind","depaPos","wishDuration","durations_1","duration","distance","abs","deceleration","_this","sqrt","Infinity","minimumDuration","maximumDuration","velocity","totalVelocity","total","displacement","threshold","initSlope","easing","option","orgPos_1","_animateParam","opt","triggerChange","_raf","triggerAnimationEnd","event","input","inputEvent","stopAnimation","animateTo","getDuration","beforeParam","getEventInfo","circularTargets","setTo","setInterrupt","restore","finish","isTrusted","triggerFinish","userWish","_createAnimationParam","retTrigger","triggerAnimationStart","getUserControl","console","warn","_animateLoop","delta","getDelta","axes","orgPos","movedPos","diffTime","currentPos","ratio","animateParam","startTime","restart","_initialEasingPer","_prevEasingPer","_durationOffset","done","complete","prevPos_1","directions_1","originalIntendedPos_1","loop_1","easingPer","rangeOffset","nextPos","circulatedPos","isCanceled","_getFinalPos","originalIntendedPos","_getRoundUnit","minRoundUnit","getAxisOptions","_axes","roundPos","_getRoundPos","trigger","ComponentEvent","roundDepa","_createUserControll","__assign","bounceRatio","_getBounceRatio","holding","animationManager","eventInfo","moveTo","set","off","userControl","userDuration","interruptable","_prevented","prevented","_axis","_complementOptions","_pos","fullDepaPos","axisOptions","axis","axisOption","test","SUPPORT_POINTER","SUPPORT_MSPOINTER","preventDefault","removeEventListener","_stopContextMenu","prevEvent","center","_getCenter","movement","_getMovement","x","y","scale","_getScale","angle","deltaX","deltaY","offsetX","offsetY","deltaTime","timeStamp","srcEvent","velocityX","velocityY","preventSystemEvent","start","end","clientX","clientY","buttonCodeMap","button","_isTouchEvent","buttons","type","inputButton","addEventListener","__extends","_getButton","_isValidButton","_preventMouseButton","extendEvent","prev","pageX","pageY","EventInput","_baseTouches","touches","_getDistance","identifier","_updatePointerEvent","_removePointerEvent","_firstInputs","_recentInputs","pointerId","addFlag","id","nextSpot","prevSpot","_interruptManager","_eventManager","_axisManager","_animationManager","changeOption","isInterrupted","_isStopped","_moveDistance","hold","_isOutside","useDuration","nativeEvent","isInterrupting","__childrenAxesAlreadyChanged","_atOutside","nested","_isEndofAxis","inputDuration","isEqual","__childrenAxesAlreadyReleased","getDisplacement","triggerRelease","tn","tx","out","interpolate","startPos","_super","InterruptManager","AxisManager","EventManager","AnimationManager","inputObserver","InputObserver","setAnimationManager","mapped","split","concat","_inputs","disconnect","mapAxes","connect","index","splice","setBy","updateAnimation","destroy","Axes","Component","activeEvent","_activeEvent","_detachWindowEvent","_observer","release","onRelease","thresholdAngle","iOSEdgeSwipeThreshold","releaseOnScroll","_onPanstart","_onPanmove","_onPanend","useHorizontal","useVertical","_direction","observer","_detachElementEvent","_attachElementEvent","_originalCssProps","_enabled","edgeThreshold","panEvent","onEventStart","getTouches","cancelable","_atRightEdge","innerWidth","_attachWindowEvent","onEventMove","toAngle","getDirectionByAngle","_forceRelease","_rightEdgeTimer","_getOffset","prevent","some","stopPropagation","change","onEventEnd","move","Error","properties","DIRECTION_ALL","rect","isEnabled","getBoundingClientRect","_coefficientForDistanceToAngle","width","_rotateOrigin","left","top","height","_prevAngle","_triggerChange","vx","vy","_lastDiff","_getPosFromOrigin","positiveAngle","quadrant","_getQuadrant","diff","_getDifference","_prevQuadrant","prevAngle","prevQuadrant","q","PanInput","_onPinchStart","_onPinchMove","_onPinchEnd","_detachEvent","_attachEvent","pinchEvent","_baseValue","_pinchFlag","pinchScale","releaseDelay","useNormalized","_onWheel","_holding","_timer","_onKeydown","_onKeyup","getAttribute","setAttribute","offsets","isMoveKey","keyCode","RotatePanInput","PinchInput","WheelInput","MoveKeyInput"],"mappings":"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"}