{"version":3,"file":"axes.pkgd.min.js","sources":["../src/Coordinate.ts","../src/browser.ts","../src/utils.ts","../src/const.ts","../src/AnimationManager.ts","../src/inputType/InputType.ts","../src/inputType/PanInput.ts","../src/EventManager.ts","../src/InterruptManager.ts","../src/AxisManager.ts","../src/eventInput/EventInput.ts","../src/eventInput/MouseEventInput.ts","../src/eventInput/TouchEventInput.ts","../src/eventInput/PointerEventInput.ts","../src/eventInput/TouchMouseEventInput.ts","../src/InputObserver.ts","../src/Axes.ts","../src/inputType/RotatePanInput.ts","../src/inputType/PinchInput.ts","../src/inputType/WheelInput.ts","../src/inputType/MoveKeyInput.ts","../src/index.umd.ts"],"sourcesContent":["export const getInsidePosition = (\n  destPos: number,\n  range: number[],\n  circular: boolean[],\n  bounce?: number[]\n): number => {\n  let toDestPos: number = destPos;\n  const targetRange: number[] = [\n    circular[0] ? range[0] : bounce ? range[0] - bounce[0] : range[0],\n    circular[1] ? range[1] : bounce ? range[1] + bounce[1] : range[1],\n  ];\n\n  toDestPos = Math.max(targetRange[0], toDestPos);\n  toDestPos = Math.min(targetRange[1], toDestPos);\n\n  return toDestPos;\n};\n\n// determine outside\nexport const isOutside = (pos: number, range: number[]): boolean => {\n  return pos < range[0] || pos > range[1];\n};\n\nexport const getDuration = (distance: number, deceleration): number => {\n  const duration = Math.sqrt((distance / deceleration) * 2);\n\n  // when duration is under 100, then value is zero\n  return duration < 100 ? 0 : duration;\n};\n\nexport const isCircularable = (\n  destPos: number,\n  range: number[],\n  circular: boolean[]\n): boolean => {\n  return (\n    (circular[1] && destPos > range[1]) || (circular[0] && destPos < range[0])\n  );\n};\n\nexport const getCirculatedPos = (\n  pos: number,\n  range: number[],\n  circular: boolean[]\n): number => {\n  let toPos = pos;\n  const min = range[0];\n  const max = range[1];\n  const length = max - min;\n\n  if (circular[1] && pos > max) {\n    // right\n    toPos = ((toPos - max) % length) + min;\n  }\n  if (circular[0] && pos < min) {\n    // left\n    toPos = ((toPos - min) % length) + max;\n  }\n  return toPos;\n};\n","/* eslint-disable no-new-func, no-nested-ternary */\n\nlet win: any;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {\n    navigator: {\n      userAgent: \"\",\n    },\n  };\n} else {\n  win = window;\n}\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexport { win as window };\n","import { window } from \"./browser\";\nimport { PREVENT_SCROLL_CSSPROPS } from \"./const\";\nimport { ObjectInterface } from \"./types\";\n\ndeclare let jQuery: any;\n\nexport const toArray = (nodes: NodeList): HTMLElement[] => {\n  // const el = Array.prototype.slice.call(nodes);\n  // for IE8\n  const el = [];\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    el.push(nodes[i]);\n  }\n  return el;\n};\n\nexport const $ = (param, multi = false) => {\n  let el;\n\n  if (typeof param === \"string\") {\n    // String (HTML, Selector)\n    // check if string is HTML tag format\n    const match = param.match(/^<([a-z]+)\\s*([^>]*)>/);\n\n    // creating element\n    if (match) {\n      // HTML\n      const dummy = document.createElement(\"div\");\n\n      dummy.innerHTML = param;\n      el = toArray(dummy.childNodes);\n    } else {\n      // Selector\n      el = toArray(document.querySelectorAll(param));\n    }\n    if (!multi) {\n      el = el.length >= 1 ? el[0] : undefined;\n    }\n  } else if (param === window) {\n    // window\n    el = param;\n  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {\n    // HTMLElement, Document\n    el = param;\n  } else if (\n    (\"jQuery\" in window && param instanceof jQuery) ||\n    param.constructor.prototype.jquery\n  ) {\n    // jQuery\n    el = multi ? param.toArray() : param.get(0);\n  } else if (Array.isArray(param)) {\n    el = param.map((v) => $(v));\n    if (!multi) {\n      el = el.length >= 1 ? el[0] : undefined;\n    }\n  }\n  return el;\n};\n\nlet raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame;\nlet caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;\nif (raf && !caf) {\n  const keyInfo = {};\n  const oldraf = raf;\n  raf = (callback: FrameRequestCallback) => {\n    const wrapCallback = (timestamp: number) => {\n      if (keyInfo[key]) {\n        callback(timestamp);\n      }\n    };\n    const key = oldraf(wrapCallback);\n    keyInfo[key] = true;\n    return key;\n  };\n  caf = (key: number) => {\n    delete keyInfo[key];\n  };\n} else if (!(raf && caf)) {\n  raf = (callback: FrameRequestCallback) => {\n    return window.setTimeout(() => {\n      callback(\n        ((window.performance &&\n          window.performance.now &&\n          window.performance.now()) as number) || new Date().getTime()\n      );\n    }, 16);\n  };\n  caf = window.clearTimeout;\n}\n\n/**\n * A polyfill for the window.requestAnimationFrame() method.\n * @see  https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n * @private\n */\nexport const requestAnimationFrame = (fp) => {\n  return raf(fp);\n};\n/**\n * A polyfill for the window.cancelAnimationFrame() method. It cancels an animation executed through a call to the requestAnimationFrame() method.\n * @param {Number} key −\tThe ID value returned through a call to the requestAnimationFrame() method. <ko>requestAnimationFrame() 메서드가 반환한 아이디 값</ko>\n * @see  https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame\n * @private\n */\nexport const cancelAnimationFrame = (key) => {\n  caf(key);\n};\n\nexport const map = <T, U>(\n  obj: ObjectInterface<T>,\n  callback: (value: T, key: string) => U\n): ObjectInterface<U> => {\n  const tranformed: ObjectInterface<U> = {};\n\n  for (const k in obj) {\n    if (k) {\n      tranformed[k] = callback(obj[k], k);\n    }\n  }\n  return tranformed;\n};\n\nexport const filter = <T>(\n  obj: ObjectInterface<T>,\n  callback: (value: T, key: string) => boolean\n): ObjectInterface<T> => {\n  const filtered: ObjectInterface<T> = {};\n\n  for (const k in obj) {\n    if (k && callback(obj[k], k)) {\n      filtered[k] = obj[k];\n    }\n  }\n  return filtered;\n};\nexport const every = <T>(\n  obj: ObjectInterface<T>,\n  callback: (value: T, key: string) => boolean\n) => {\n  for (const k in obj) {\n    if (k && !callback(obj[k], k)) {\n      return false;\n    }\n  }\n  return true;\n};\nexport const equal = (\n  target: ObjectInterface,\n  base: ObjectInterface\n): boolean => {\n  return every(target, (v, k) => v === base[k]);\n};\n\nconst roundNumFunc = {};\n\nexport const roundNumber = (num: number, roundUnit: number) => {\n  // Cache for performance\n  if (!roundNumFunc[roundUnit]) {\n    roundNumFunc[roundUnit] = getRoundFunc(roundUnit);\n  }\n\n  return roundNumFunc[roundUnit](num);\n};\n\nexport const roundNumbers = (\n  num: ObjectInterface<number>,\n  roundUnit: ObjectInterface<number> | number\n): ObjectInterface<number> => {\n  if (!num || !roundUnit) {\n    return num;\n  }\n  return map(num, (value, key) =>\n    roundNumber(\n      value,\n      typeof roundUnit === \"number\" ? roundUnit : roundUnit[key]\n    )\n  );\n};\n\nexport const getDecimalPlace = (val: number): number => {\n  if (!isFinite(val)) {\n    return 0;\n  }\n\n  const v = `${val}`;\n\n  if (v.indexOf(\"e\") >= 0) {\n    // Exponential Format\n    // 1e-10, 1e-12\n    let p = 0;\n    let e = 1;\n\n    while (Math.round(val * e) / e !== val) {\n      e *= 10;\n      p++;\n    }\n\n    return p;\n  }\n\n  // In general, following has performance benefit.\n  // https://jsperf.com/precision-calculation\n  return v.indexOf(\".\") >= 0 ? v.length - v.indexOf(\".\") - 1 : 0;\n};\n\nexport const inversePow = (n: number) => {\n  // replace Math.pow(10, -n) to solve floating point issue.\n  // eg. Math.pow(10, -4) => 0.00009999999999999999\n  return 1 / Math.pow(10, n);\n};\n\nexport const getRoundFunc = (v: number) => {\n  const p = v < 1 ? Math.pow(10, getDecimalPlace(v)) : 1;\n\n  return (n: number) => {\n    if (v === 0) {\n      return 0;\n    }\n\n    return Math.round(Math.round(n / v) * v * p) / p;\n  };\n};\n\nexport const getAngle = (posX: number, posY: number) => {\n  return (Math.atan2(posY, posX) * 180) / Math.PI;\n};\n\nexport const setCssProps = (\n  element: HTMLElement,\n  originalCssProps?: { [key: string]: string }\n): { [key: string]: string } => {\n  const oldCssProps = {};\n  if (element.style) {\n    const newCssProps = originalCssProps\n      ? originalCssProps\n      : PREVENT_SCROLL_CSSPROPS;\n    Object.keys(newCssProps).forEach((prop) => {\n      oldCssProps[prop] = element.style[prop];\n      element.style[prop] = newCssProps[prop];\n    });\n  }\n  return oldCssProps;\n};\n","export const DIRECTION_NONE = 1;\nexport const DIRECTION_LEFT = 2;\nexport const DIRECTION_RIGHT = 4;\nexport const DIRECTION_HORIZONTAL = 2 | 4;\nexport const DIRECTION_UP = 8;\nexport const DIRECTION_DOWN = 16;\nexport const DIRECTION_VERTICAL = 8 | 16;\nexport const DIRECTION_ALL = 2 | 4 | 8 | 16;\n\nimport getAgent from \"@egjs/agent\";\n\nimport { window } from \"./browser\";\n\nexport const IOS_EDGE_THRESHOLD = 30;\nexport const IS_IOS_SAFARI =\n  \"ontouchstart\" in window && getAgent().browser.name === \"safari\";\n\nexport const TRANSFORM = (() => {\n  if (typeof document === \"undefined\") {\n    return \"\";\n  }\n  const bodyStyle = (document.head || document.getElementsByTagName(\"head\")[0])\n    .style;\n  const target = [\n    \"transform\",\n    \"webkitTransform\",\n    \"msTransform\",\n    \"mozTransform\",\n  ];\n  for (let i = 0, len = target.length; i < len; i++) {\n    if (target[i] in bodyStyle) {\n      return target[i];\n    }\n  }\n  return \"\";\n})();\n\nexport const PREVENT_SCROLL_CSSPROPS = {\n  \"touch-action\": \"none\",\n  \"user-select\": \"none\",\n  \"-webkit-user-drag\": \"none\",\n};\n","import {\n  getInsidePosition,\n  isCircularable,\n  getCirculatedPos,\n  getDuration,\n} from \"./Coordinate\";\nimport { Axis, AxisManager } from \"./AxisManager\";\nimport { InterruptManager } from \"./InterruptManager\";\nimport { EventManager, ChangeEventOption } from \"./EventManager\";\nimport {\n  requestAnimationFrame,\n  cancelAnimationFrame,\n  map,\n  every,\n  filter,\n  equal,\n  roundNumber,\n  getDecimalPlace,\n  inversePow,\n} from \"./utils\";\nimport { AxesOption } from \"./Axes\";\nimport {\n  AnimationParam,\n  ObjectInterface,\n  UpdateAnimationOption,\n} from \"./types\";\n\nconst clamp = (value: number, min: number, max: number): number => {\n  return Math.max(Math.min(value, max), min);\n};\n\nexport class AnimationManager {\n  public itm: InterruptManager;\n  public em: EventManager;\n  public axm: AxisManager;\n  private _raf: number;\n  private _animateParam: AnimationParam;\n  private _initialEasingPer: number;\n  private _prevEasingPer: number;\n  private _durationOffset: number;\n  private _options: AxesOption;\n\n  public constructor({\n    options,\n    itm,\n    em,\n    axm,\n  }: {\n    options: AxesOption;\n    itm: InterruptManager;\n    em: EventManager;\n    axm: AxisManager;\n  }) {\n    this._options = options;\n    this.itm = itm;\n    this.em = em;\n    this.axm = axm;\n    this.animationEnd = this.animationEnd.bind(this);\n  }\n\n  public getDuration(\n    depaPos: Axis,\n    destPos: Axis,\n    wishDuration?: number\n  ): number {\n    let duration: number;\n    if (typeof wishDuration !== \"undefined\") {\n      duration = wishDuration;\n    } else {\n      const durations: Axis = map(destPos, (v, k) =>\n        getDuration(Math.abs(v - depaPos[k]), this._options.deceleration)\n      );\n      duration = Object.keys(durations).reduce(\n        (max, v) => Math.max(max, durations[v]),\n        -Infinity\n      );\n    }\n    return clamp(\n      duration,\n      this._options.minimumDuration,\n      this._options.maximumDuration\n    );\n  }\n\n  public getDisplacement(velocity: number[]): number[] {\n    const totalVelocity = Math.pow(\n      velocity.reduce((total, v) => total + v * v, 0),\n      1 / velocity.length\n    );\n    const duration = Math.abs(totalVelocity / -this._options.deceleration);\n    return velocity.map((v) => (v / 2) * duration);\n  }\n\n  public interpolate(displacement: number, threshold: number): number {\n    const initSlope = this.easing(0.00001) / 0.00001;\n    return this.easing(displacement / (threshold * initSlope)) * threshold;\n  }\n\n  public stopAnimation(axes: string[], option?: ChangeEventOption): void {\n    if (this._animateParam && axes.length) {\n      const orgPos: Axis = this.axm.get(axes);\n      const pos: Axis = this.axm.map(orgPos, (v, opt) =>\n        getCirculatedPos(v, opt.range, opt.circular as boolean[])\n      );\n      if (!every(pos, (v, k) => orgPos[k] === v)) {\n        this.em.triggerChange(pos, false, orgPos, option, !!option);\n      }\n      this._animateParam = null;\n      if (this._raf) {\n        cancelAnimationFrame(this._raf);\n      }\n      this._raf = null;\n      this.em.triggerAnimationEnd(!!option?.event);\n    }\n  }\n\n  public getEventInfo(): ChangeEventOption {\n    if (\n      this._animateParam &&\n      this._animateParam.input &&\n      this._animateParam.inputEvent\n    ) {\n      return {\n        input: this._animateParam.input,\n        event: this._animateParam.inputEvent,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  public restore(option: ChangeEventOption): void {\n    const pos: Axis = this.axm.get();\n    const destPos: Axis = this.axm.map(pos, (v, opt) =>\n      Math.min(opt.range[1], Math.max(opt.range[0], v))\n    );\n    this.animateTo(destPos, this.getDuration(pos, destPos), option);\n  }\n\n  public animationEnd(): void {\n    const beforeParam: ChangeEventOption = this.getEventInfo();\n    this._animateParam = null;\n\n    // for Circular\n    const circularTargets = this.axm.filter(this.axm.get(), (v, opt) =>\n      isCircularable(v, opt.range, opt.circular as boolean[])\n    );\n    if (Object.keys(circularTargets).length > 0) {\n      this.setTo(\n        this.axm.map(circularTargets, (v, opt) =>\n          getCirculatedPos(v, opt.range, opt.circular as boolean[])\n        )\n      );\n    }\n    this.itm.setInterrupt(false);\n    this.em.triggerAnimationEnd(!!beforeParam);\n    if (this.axm.isOutside()) {\n      this.restore(beforeParam);\n    } else {\n      this.finish(!!beforeParam);\n    }\n  }\n\n  public finish(isTrusted: boolean): void {\n    this._animateParam = null;\n    this.itm.setInterrupt(false);\n    this.em.triggerFinish(isTrusted);\n  }\n\n  public getUserControl(param: AnimationParam): {\n    destPos: Axis;\n    duration: number;\n  } {\n    const userWish = param.setTo();\n    userWish.destPos = this.axm.get(userWish.destPos);\n    userWish.duration = clamp(\n      userWish.duration,\n      this._options.minimumDuration,\n      this._options.maximumDuration\n    );\n    return userWish;\n  }\n\n  public animateTo(\n    destPos: Axis,\n    duration: number,\n    option?: ChangeEventOption\n  ): void {\n    const param: AnimationParam = this._createAnimationParam(\n      destPos,\n      duration,\n      option\n    );\n    const depaPos = { ...param.depaPos };\n    const retTrigger = this.em.triggerAnimationStart(param);\n\n    // to control\n    const userWish = this.getUserControl(param);\n\n    // You can't stop the 'animationStart' event when 'circular' is true.\n    if (\n      !retTrigger &&\n      this.axm.every(userWish.destPos, (v, opt) =>\n        isCircularable(v, opt.range, opt.circular as boolean[])\n      )\n    ) {\n      console.warn(\n        \"You can't stop the 'animation' event when 'circular' is true.\"\n      );\n    }\n\n    if (retTrigger && !equal(userWish.destPos, depaPos)) {\n      const inputEvent = option?.event || null;\n      this._animateLoop(\n        {\n          depaPos,\n          destPos: userWish.destPos,\n          duration: userWish.duration,\n          delta: this.axm.getDelta(depaPos, userWish.destPos),\n          isTrusted: !!inputEvent,\n          inputEvent,\n          input: option?.input || null,\n        },\n        () => this.animationEnd()\n      );\n    }\n  }\n\n  public easing(p: number): number {\n    return p > 1 ? 1 : this._options.easing(p);\n  }\n\n  public setTo(pos: Axis, duration: number = 0) {\n    const axes: string[] = Object.keys(pos);\n    this.stopAnimation(axes);\n    const orgPos: Axis = this.axm.get(axes);\n\n    if (equal(pos, orgPos)) {\n      return this;\n    }\n    this.itm.setInterrupt(true);\n    let movedPos = filter(pos, (v, k) => orgPos[k] !== v);\n    if (!Object.keys(movedPos).length) {\n      return this;\n    }\n\n    movedPos = this.axm.map(movedPos, (v, opt) => {\n      const { range, circular } = opt;\n\n      if (circular && (circular[0] || circular[1])) {\n        return v;\n      } else {\n        return getInsidePosition(v, range, circular as boolean[]);\n      }\n    });\n\n    if (equal(movedPos, orgPos)) {\n      return this;\n    }\n\n    if (duration > 0) {\n      this.animateTo(movedPos, duration);\n    } else {\n      this.em.triggerChange(movedPos);\n      this.finish(false);\n    }\n\n    return this;\n  }\n\n  public setBy(pos: Axis, duration = 0) {\n    return this.setTo(\n      map(this.axm.get(Object.keys(pos)), (v, k) => v + pos[k]),\n      duration\n    );\n  }\n\n  public updateAnimation(options: UpdateAnimationOption): void {\n    const animateParam = this._animateParam;\n    if (!animateParam) {\n      return;\n    }\n\n    const diffTime = new Date().getTime() - animateParam.startTime;\n    const pos = options?.destPos || animateParam.destPos;\n    const duration = options?.duration || animateParam.duration;\n    if (options?.restart || duration <= diffTime) {\n      this.setTo(pos, duration - diffTime);\n      return;\n    }\n    if (options?.destPos) {\n      const currentPos = this.axm.get();\n      // When destination is changed, new delta should be calculated as remaining percent.\n      // For example, moving x:0, y:0 to x:200, y:200 and it has current easing percent of 92%. coordinate is x:184 and y:184\n      // If destination changes to x:300, y:300. xdelta:200, ydelta:200 changes to xdelta:116, ydelta:116 and use remaining easingPer as 100%, not 8% as previous.\n      // Therefore, original easingPer by time is kept. And divided by (1 - self._initialEasingPer) which means new total easing percent. Like calculating 8% as 100%.\n      this._initialEasingPer = this._prevEasingPer;\n      animateParam.delta = this.axm.getDelta(currentPos, pos);\n      animateParam.destPos = pos;\n    }\n    if (options?.duration) {\n      const ratio = (diffTime + this._durationOffset) / animateParam.duration;\n      // Use durationOffset for keeping animation ratio after duration is changed.\n      // newRatio = (diffTime + newDurationOffset) / newDuration = oldRatio\n      // newDurationOffset = oldRatio * newDuration - diffTime\n      this._durationOffset = ratio * duration - diffTime;\n      animateParam.duration = duration;\n    }\n  }\n\n  private _createAnimationParam(\n    pos: Axis,\n    duration: number,\n    option?: ChangeEventOption\n  ): AnimationParam {\n    const depaPos: Axis = this.axm.get();\n    const destPos: Axis = pos;\n    const inputEvent = option?.event || null;\n    return {\n      depaPos,\n      destPos,\n      duration: clamp(\n        duration,\n        this._options.minimumDuration,\n        this._options.maximumDuration\n      ),\n      delta: this.axm.getDelta(depaPos, destPos),\n      inputEvent,\n      input: option?.input || null,\n      isTrusted: !!inputEvent,\n      done: this.animationEnd,\n    };\n  }\n\n  private _animateLoop(param: AnimationParam, complete: () => void): void {\n    if (param.duration) {\n      let prevPos = param.depaPos;\n      this._initialEasingPer = 0;\n      this._prevEasingPer = 0;\n      this._durationOffset = 0;\n      this._animateParam = {\n        ...param,\n        startTime: new Date().getTime(),\n      };\n      const directions = map(prevPos, (value, key) => {\n        return value <= param.destPos[key] ? 1 : -1;\n      });\n      const originalIntendedPos = map(param.destPos, (v) => v);\n      const loop = () => {\n        const animateParam = this._animateParam;\n        const diffTime = new Date().getTime() - animateParam.startTime;\n        const ratio = (diffTime + this._durationOffset) / animateParam.duration;\n        const easingPer = this.easing(ratio);\n        this._raf = null;\n        const toPos: Axis = this.axm.map(prevPos, (pos, options, key) => {\n          const nextPos =\n            ratio >= 1\n              ? animateParam.destPos[key]\n              : pos +\n                (animateParam.delta[key] * (easingPer - this._prevEasingPer)) /\n                  (1 - this._initialEasingPer);\n\n          // Subtract distance from distance already moved.\n          // Recalculate the remaining distance.\n          // Fix the bouncing phenomenon by changing the range.\n          const circulatedPos = getCirculatedPos(\n            nextPos,\n            options.range,\n            options.circular as boolean[]\n          );\n          if (nextPos !== circulatedPos) {\n            // circular\n            const rangeOffset =\n              directions[key] * (options.range[1] - options.range[0]);\n\n            animateParam.destPos[key] -= rangeOffset;\n            prevPos[key] -= rangeOffset;\n          }\n          return circulatedPos;\n        });\n        const isCanceled = !this.em.triggerChange(toPos, false, prevPos);\n\n        prevPos = toPos;\n        this._prevEasingPer = easingPer;\n        if (easingPer >= 1) {\n          animateParam.destPos = this._getFinalPos(\n            animateParam.destPos,\n            originalIntendedPos\n          );\n\n          if (\n            !equal(\n              animateParam.destPos,\n              this.axm.get(Object.keys(animateParam.destPos))\n            )\n          ) {\n            this.em.triggerChange(animateParam.destPos, true, prevPos);\n          }\n          complete();\n          return;\n        } else if (isCanceled) {\n          this.finish(false);\n        } else {\n          // animationEnd\n          this._raf = requestAnimationFrame(loop);\n        }\n      };\n      loop();\n    } else {\n      this.em.triggerChange(param.destPos, true);\n      complete();\n    }\n  }\n\n  /**\n   * Get estimated final value.\n   *\n   * If destPos is within the 'error range' of the original intended position, the initial intended position is returned.\n   *   - eg. original intended pos: 100, destPos: 100.0000000004 ==> return 100;\n   * If dest Pos is outside the 'range of error' compared to the originally intended pos, it is returned rounded based on the originally intended pos.\n   *   - eg. original intended pos: 100.123 destPos: 50.12345 => return 50.123\n   * @param originalIntendedPos\n   * @param destPos\n   */\n  private _getFinalPos(\n    destPos: ObjectInterface<number>,\n    originalIntendedPos: ObjectInterface<number>\n  ): Axis {\n    // compare destPos and originalIntendedPos\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const ERROR_LIMIT = 0.000001;\n    const finalPos = map(destPos, (value, key) => {\n      if (\n        value >= originalIntendedPos[key] - ERROR_LIMIT &&\n        value <= originalIntendedPos[key] + ERROR_LIMIT\n      ) {\n        // In error range, return original intended\n        return originalIntendedPos[key];\n      } else {\n        // Out of error range, return rounded pos.\n        const roundUnit = this._getRoundUnit(value, key);\n        const result = roundNumber(value, roundUnit);\n        return result;\n      }\n    });\n    return finalPos;\n  }\n\n  private _getRoundUnit(val: number, key: string): number {\n    const roundUnit = this._options.round; // manual mode\n    let minRoundUnit = null; // auto mode\n\n    // auto mode\n    if (!roundUnit) {\n      // Get minimum round unit\n      const options = this.axm.getAxisOptions(key);\n      minRoundUnit = inversePow(\n        Math.max(\n          getDecimalPlace(options.range[0]),\n          getDecimalPlace(options.range[1]),\n          getDecimalPlace(val)\n        )\n      );\n    }\n\n    return minRoundUnit || roundUnit;\n  }\n}\n","import { Axis } from \"../AxisManager\";\nimport { AxesOption } from \"../Axes\";\nimport { ActiveInput } from \"../types\";\nimport { MouseEventInput } from \"../eventInput/MouseEventInput\";\nimport { TouchEventInput } from \"../eventInput/TouchEventInput\";\nimport { PointerEventInput } from \"../eventInput/PointerEventInput\";\nimport { TouchMouseEventInput } from \"../eventInput/TouchMouseEventInput\";\nimport {\n  SUPPORT_POINTER_EVENTS,\n  SUPPORT_TOUCH,\n} from \"../eventInput/EventInput\";\n\nexport interface IInputType {\n  axes: string[];\n  element: HTMLElement;\n  mapAxes(axes: string[]);\n  connect(observer: IInputTypeObserver): IInputType;\n  disconnect();\n  destroy();\n  enable?();\n  disable?();\n  isEnable?(): boolean;\n}\n\nexport interface IInputTypeObserver {\n  options: AxesOption;\n  get(inputType: IInputType): Axis;\n  change(inputType: IInputType, event, offset: Axis, useDuration?: boolean);\n  hold(inputType: IInputType, event);\n  release(\n    inputType: IInputType,\n    event,\n    velocity: number[],\n    inputDuration?: number\n  );\n}\n\nexport const toAxis = (source: string[], offset: number[]): Axis => {\n  return offset.reduce((acc, v, i) => {\n    if (source[i]) {\n      acc[source[i]] = v;\n    }\n    return acc;\n  }, {});\n};\n\nexport const convertInputType = (inputType: string[] = []): ActiveInput => {\n  let hasTouch = false;\n  let hasMouse = false;\n  let hasPointer = false;\n\n  inputType.forEach((v) => {\n    switch (v) {\n      case \"mouse\":\n        hasMouse = true;\n        break;\n      case \"touch\":\n        hasTouch = SUPPORT_TOUCH;\n        break;\n      case \"pointer\":\n        hasPointer = SUPPORT_POINTER_EVENTS;\n      // no default\n    }\n  });\n  if (hasPointer) {\n    return new PointerEventInput();\n  } else if (hasTouch && hasMouse) {\n    return new TouchMouseEventInput();\n  } else if (hasTouch) {\n    return new TouchEventInput();\n  } else if (hasMouse) {\n    return new MouseEventInput();\n  }\n  return null;\n};\n","import { $, setCssProps } from \"../utils\";\nimport {\n  IS_IOS_SAFARI,\n  IOS_EDGE_THRESHOLD,\n  DIRECTION_NONE,\n  DIRECTION_VERTICAL,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_ALL,\n  PREVENT_SCROLL_CSSPROPS,\n} from \"../const\";\nimport { ActiveInput, InputEventType } from \"../types\";\n\nimport {\n  convertInputType,\n  IInputType,\n  IInputTypeObserver,\n  toAxis,\n} from \"./InputType\";\n\nexport interface PanInputOption {\n  inputType?: string[];\n  scale?: number[];\n  thresholdAngle?: number;\n  threshold?: number;\n  iOSEdgeSwipeThreshold?: number;\n  releaseOnScroll?: boolean;\n}\n\n// get user's direction\nexport const getDirectionByAngle = (\n  angle: number,\n  thresholdAngle: number\n): number => {\n  if (thresholdAngle < 0 || thresholdAngle > 90) {\n    return DIRECTION_NONE;\n  }\n  const toAngle = Math.abs(angle);\n\n  return toAngle > thresholdAngle && toAngle < 180 - thresholdAngle\n    ? DIRECTION_VERTICAL\n    : DIRECTION_HORIZONTAL;\n};\n\nexport const useDirection = (checkType, direction, userDirection?): boolean => {\n  if (userDirection) {\n    return !!(\n      direction === DIRECTION_ALL ||\n      (direction & checkType && userDirection & checkType)\n    );\n  } else {\n    return !!(direction & checkType);\n  }\n};\n\n/**\n * @typedef {Object} PanInputOption The option object of the eg.Axes.PanInput module.\n * @ko eg.Axes.PanInput 모듈의 옵션 객체\n * @property {String[]} [inputType=[\"touch\",\"mouse\", \"pointer\"]] Types of input devices.<br>- touch: Touch screen<br>- mouse: Mouse <ko>입력 장치 종류.<br>- touch: 터치 입력 장치<br>- mouse: 마우스</ko>\n * @property {Number[]} [scale] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @property {Number} [scale.0=1] horizontal axis scale <ko>수평축 배율</ko>\n * @property {Number} [scale.1=1] vertical axis scale <ko>수직축 배율</ko>\n * @property {Number} [thresholdAngle=45] The threshold value that determines whether user action is horizontal or vertical (0~90) <ko>사용자의 동작이 가로 방향인지 세로 방향인지 판단하는 기준 각도(0~90)</ko>\n * @property {Number} [threshold=0] Minimal pan distance required before recognizing <ko>사용자의 Pan 동작을 인식하기 위해산 최소한의 거리</ko>\n * @property {Number} [iOSEdgeSwipeThreshold=30] Area (px) that can go to the next page when swiping the right edge in iOS safari <ko>iOS Safari에서 오른쪽 엣지를 스와이프 하는 경우 다음 페이지로 넘어갈 수 있는 영역(px)</ko>\n **/\n/**\n * @class eg.Axes.PanInput\n * @classdesc A module that passes the amount of change to eg.Axes when the mouse or touchscreen is down and moved. use less than two axes.\n * @ko 마우스나 터치 스크린을 누르고 움직일때의 변화량을 eg.Axes에 전달하는 모듈. 두개 이하의 축을 사용한다.\n *\n * @example\n * const pan = new eg.Axes.PanInput(\"#area\", {\n * \t\tinputType: [\"touch\"],\n * \t\tscale: [1, 1.3],\n * });\n *\n * // Connect the 'something2' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.\n * // Connect the 'somethingN' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.\n * axes.connect([\"something2\", \"somethingN\"], pan); // or axes.connect(\"something2 somethingN\", pan);\n *\n * // Connect only one 'something1' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.\n * axes.connect([\"something1\"], pan); // or axes.connect(\"something1\", pan);\n *\n * // Connect only one 'something2' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.\n * axes.connect([\"\", \"something2\"], pan); // or axes.connect(\" something2\", pan);\n *\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.PanInput module <ko>eg.Axes.PanInput 모듈을 사용할 엘리먼트</ko>\n * @param {PanInputOption} [options] The option object of the eg.Axes.PanInput module<ko>eg.Axes.PanInput 모듈의 옵션 객체</ko>\n */\nexport class PanInput implements IInputType {\n  public options: PanInputOption;\n  public axes: string[] = [];\n  public element: HTMLElement = null;\n  protected _observer: IInputTypeObserver;\n  protected _direction;\n  protected _panFlag = false;\n  protected _enabled = false;\n  protected _activeInput: ActiveInput = null;\n  private _originalCssProps: { [key: string]: string };\n  private _atRightEdge = false;\n  private _rightEdgeTimer = 0;\n\n  public constructor(el: string | HTMLElement, options?: PanInputOption) {\n    this.element = $(el);\n    this.options = {\n      inputType: [\"touch\", \"mouse\", \"pointer\"],\n      scale: [1, 1],\n      thresholdAngle: 45,\n      threshold: 0,\n      iOSEdgeSwipeThreshold: IOS_EDGE_THRESHOLD,\n      releaseOnScroll: false,\n      ...options,\n    };\n    this._onPanstart = this._onPanstart.bind(this);\n    this._onPanmove = this._onPanmove.bind(this);\n    this._onPanend = this._onPanend.bind(this);\n  }\n\n  public mapAxes(axes: string[]) {\n    const useHorizontal = !!axes[0];\n    const useVertical = !!axes[1];\n    if (useHorizontal && useVertical) {\n      this._direction = DIRECTION_ALL;\n    } else if (useHorizontal) {\n      this._direction = DIRECTION_HORIZONTAL;\n    } else if (useVertical) {\n      this._direction = DIRECTION_VERTICAL;\n    } else {\n      this._direction = DIRECTION_NONE;\n    }\n    this.axes = axes;\n  }\n\n  public connect(observer: IInputTypeObserver): IInputType {\n    if (this._activeInput) {\n      this._detachEvent();\n    }\n    this._attachEvent(observer);\n    this._originalCssProps = setCssProps(this.element);\n    return this;\n  }\n\n  public disconnect() {\n    this._detachEvent();\n    if (this._originalCssProps !== PREVENT_SCROLL_CSSPROPS) {\n      setCssProps(this.element, this._originalCssProps);\n    }\n    this._direction = DIRECTION_NONE;\n    return this;\n  }\n\n  /**\n   * Destroys elements, properties, and events used in a module.\n   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n   * @method eg.Axes.PanInput#destroy\n   */\n  public destroy() {\n    this.disconnect();\n    this.element = null;\n  }\n\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @method eg.Axes.PanInput#enable\n   * @return {eg.Axes.PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enable() {\n    this._enabled = true;\n    return this;\n  }\n\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @method eg.Axes.PanInput#disable\n   * @return {eg.Axes.PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disable() {\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @method eg.Axes.PanInput#isEnable\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  protected _onPanstart(event: InputEventType) {\n    this._activeInput.onEventStart(event);\n    if (!this._enabled || this._activeInput.getTouches(event) > 1) {\n      return;\n    }\n\n    const panEvent = this._activeInput.extendEvent(event);\n    this._panFlag = false;\n\n    if (panEvent.srcEvent.cancelable !== false) {\n      const edgeThreshold = this.options.iOSEdgeSwipeThreshold;\n\n      this._observer.hold(this, panEvent);\n      this._atRightEdge =\n        IS_IOS_SAFARI && panEvent.center.x > window.innerWidth - edgeThreshold;\n      this._panFlag = true;\n      this._activeInput.prevEvent = panEvent;\n    }\n  }\n\n  protected _onPanmove(event: InputEventType) {\n    this._activeInput.onEventMove(event);\n    if (\n      !this._panFlag ||\n      !this._enabled ||\n      this._activeInput.getTouches(event) > 1\n    ) {\n      return;\n    }\n\n    const panEvent = this._activeInput.extendEvent(event);\n    const { iOSEdgeSwipeThreshold, releaseOnScroll } = this.options;\n    const userDirection = getDirectionByAngle(\n      panEvent.angle,\n      this.options.thresholdAngle\n    );\n\n    if (releaseOnScroll && !panEvent.srcEvent.cancelable) {\n      this._onPanend(event);\n      return;\n    }\n\n    if (this._activeInput.prevEvent && IS_IOS_SAFARI) {\n      const swipeLeftToRight = panEvent.center.x < 0;\n\n      if (swipeLeftToRight) {\n        // iOS swipe left => right\n        this._onPanend(event);\n        return;\n      } else if (this._atRightEdge) {\n        clearTimeout(this._rightEdgeTimer);\n\n        // - is right to left\n        const swipeRightToLeft = panEvent.deltaX < -iOSEdgeSwipeThreshold;\n\n        if (swipeRightToLeft) {\n          this._atRightEdge = false;\n        } else {\n          // iOS swipe right => left\n          this._rightEdgeTimer = window.setTimeout(() => {\n            this._onPanend(event);\n          }, 100);\n        }\n      }\n    }\n    const offset: number[] = this._getOffset(\n      [panEvent.offsetX, panEvent.offsetY],\n      [\n        useDirection(DIRECTION_HORIZONTAL, this._direction, userDirection),\n        useDirection(DIRECTION_VERTICAL, this._direction, userDirection),\n      ]\n    );\n    const prevent = offset.some((v) => v !== 0);\n\n    if (prevent) {\n      if (panEvent.srcEvent.cancelable !== false) {\n        panEvent.srcEvent.preventDefault();\n      }\n      panEvent.srcEvent.stopPropagation();\n    }\n    panEvent.preventSystemEvent = prevent;\n    if (prevent) {\n      this._observer.change(this, panEvent, toAxis(this.axes, offset));\n    }\n    this._activeInput.prevEvent = panEvent;\n  }\n\n  protected _onPanend(event: InputEventType) {\n    this._activeInput.onEventEnd(event);\n    if (\n      !this._panFlag ||\n      !this._enabled ||\n      this._activeInput.getTouches(event) !== 0\n    ) {\n      return;\n    }\n    this._panFlag = false;\n    clearTimeout(this._rightEdgeTimer);\n    const prevEvent = this._activeInput.prevEvent;\n    const velocity = this._getOffset(\n      [\n        Math.abs(prevEvent.velocityX) * (prevEvent.offsetX < 0 ? -1 : 1),\n        Math.abs(prevEvent.velocityY) * (prevEvent.offsetY < 0 ? -1 : 1),\n      ],\n      [\n        useDirection(DIRECTION_HORIZONTAL, this._direction),\n        useDirection(DIRECTION_VERTICAL, this._direction),\n      ]\n    );\n    this._observer.release(this, prevEvent, velocity);\n  }\n\n  private _attachEvent(observer: IInputTypeObserver) {\n    const activeInput = convertInputType(this.options.inputType);\n    this._observer = observer;\n    this._enabled = true;\n    this._activeInput = activeInput;\n    activeInput.start.forEach((event) => {\n      this.element.addEventListener(event, this._onPanstart, false);\n    });\n    activeInput.move.forEach((event) => {\n      window.addEventListener(event, this._onPanmove, false);\n    });\n    activeInput.end.forEach((event) => {\n      window.addEventListener(event, this._onPanend, false);\n    });\n  }\n\n  private _detachEvent() {\n    const activeInput = this._activeInput;\n    activeInput.start.forEach((event) => {\n      this.element.removeEventListener(event, this._onPanstart, false);\n    });\n    activeInput.move.forEach((event) => {\n      window.removeEventListener(event, this._onPanmove, false);\n    });\n    activeInput.end.forEach((event) => {\n      window.removeEventListener(event, this._onPanend, false);\n    });\n    this._enabled = false;\n    this._observer = null;\n  }\n\n  private _getOffset(properties: number[], direction: boolean[]): number[] {\n    const offset: number[] = [0, 0];\n    const scale = this.options.scale;\n\n    if (direction[0]) {\n      offset[0] = properties[0] * scale[0];\n    }\n    if (direction[1]) {\n      offset[1] = properties[1] * scale[1];\n    }\n    return offset;\n  }\n}\n","import { ComponentEvent } from \"@egjs/component\";\n\nimport { IInputType } from \"./inputType/InputType\";\nimport { Axis } from \"./AxisManager\";\nimport { AnimationManager } from \"./AnimationManager\";\nimport Axes from \"./Axes\";\nimport { roundNumbers } from \"./utils\";\nimport { AnimationParam, OnAnimationStart, OnRelease } from \"./types\";\n\nexport interface ChangeEventOption {\n  input: IInputType;\n  event;\n}\n\nexport class EventManager {\n  public am: AnimationManager;\n  public constructor(private _axes: Axes) {}\n  /**\n   * This event is fired when a user holds an element on the screen of the device.\n   * @ko 사용자가 기기의 화면에 손을 대고 있을 때 발생하는 이벤트\n   * @name eg.Axes#hold\n   * @event\n   * @type {object}\n   * @property {Object.<string, number>} pos coordinate <ko>좌표 정보</ko>\n   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>\n   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"hold\", function(event) {\n   *   // event.pos\n   *   // event.input\n   *   // event.inputEvent\n   *   // isTrusted\n   * });\n   */\n  public triggerHold(pos: Axis, option: ChangeEventOption) {\n    const { roundPos } = this._getRoundPos(pos);\n\n    this._axes.trigger(\n      new ComponentEvent(\"hold\", {\n        pos: roundPos,\n        input: option.input || null,\n        inputEvent: option.event || null,\n        isTrusted: true,\n      })\n    );\n  }\n\n  /**\n   * Specifies the coordinates to move after the 'change' event. It works when the holding value of the change event is true.\n   * @ko 'change' 이벤트 이후 이동할 좌표를 지정한다. change이벤트의 holding 값이 true일 경우에 동작한다\n   * @name set\n   * @function\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"change\", function(event) {\n   *   event.holding && event.set({x: 10});\n   * });\n   */\n  /** Specifies the animation coordinates to move after the 'release' or 'animationStart' events.\n   * @ko 'release' 또는 'animationStart' 이벤트 이후 이동할 좌표를 지정한다.\n   * @name setTo\n   * @function\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @param {Number} [duration] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"animationStart\", function(event) {\n   *   event.setTo({x: 10}, 2000);\n   * });\n   */\n  /**\n   * This event is fired when a user release an element on the screen of the device.\n   * @ko 사용자가 기기의 화면에서 손을 뗐을 때 발생하는 이벤트\n   * @name eg.Axes#release\n   * @event\n   * @type {object}\n   * @property {Object.<string, number>} depaPos The coordinates when releasing an element<ko>손을 뗐을 때의 좌표 </ko>\n   * @property {Object.<string, number>} destPos The coordinates to move to after releasing an element<ko>손을 뗀 뒤에 이동할 좌표</ko>\n   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>\n   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>\n   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>\n   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"release\", function(event) {\n   *   // event.depaPos\n   *   // event.destPos\n   *   // event.delta\n   *   // event.input\n   *   // event.inputEvent\n   *   // event.setTo\n   *   // event.isTrusted\n   *\n   *   // if you want to change the animation coordinates to move after the 'release' event.\n   *   event.setTo({x: 10}, 2000);\n   * });\n   */\n  public triggerRelease(param: AnimationParam) {\n    const { roundPos, roundDepa } = this._getRoundPos(\n      param.destPos,\n      param.depaPos\n    );\n    param.destPos = roundPos;\n    param.depaPos = roundDepa;\n    param.setTo = this._createUserControll(param.destPos, param.duration);\n    this._axes.trigger(\n      new ComponentEvent(\"release\", {\n        ...param,\n        bounceRatio: this._getBounceRatio(roundPos),\n      } as OnRelease)\n    );\n  }\n\n  /**\n   * This event is fired when coordinate changes.\n   * @ko 좌표가 변경됐을 때 발생하는 이벤트\n   * @name eg.Axes#change\n   * @event\n   * @type {object}\n   * @property {Object.<string, number>} pos  The coordinate <ko>좌표</ko>\n   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>\n   * @property {Boolean} holding Indicates whether a user holds an element on the screen of the device.<ko>사용자가 기기의 화면을 누르고 있는지 여부</ko>\n   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns 'null'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>\n   * @property {Object} inputEvent The event object received from inputType. If the value is changed by animation, it returns 'null'.<ko>inputType으로 부터 받은 이벤트 객체. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>\n   * @property {set} set Specifies the coordinates to move after the event. It works when the holding value is true <ko>이벤트 이후 이동할 좌표를 지정한다. holding 값이 true일 경우에 동작한다.</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"change\", function(event) {\n   *   // event.pos\n   *   // event.delta\n   *   // event.input\n   *   // event.inputEvent\n   *   // event.holding\n   *   // event.set\n   *   // event.isTrusted\n   *\n   *   // if you want to change the coordinates to move after the 'change' event.\n   *   // it works when the holding value of the change event is true.\n   *   event.holding && event.set({x: 10});\n   * });\n   */\n  public triggerChange(\n    pos: Axis,\n    isAccurate?: boolean,\n    depaPos?: Axis,\n    option?: ChangeEventOption,\n    holding: boolean = false\n  ) {\n    const am = this.am;\n    const axm = am.axm;\n    const eventInfo = am.getEventInfo();\n    const { roundPos, roundDepa } = this._getRoundPos(pos, depaPos);\n    const moveTo = axm.moveTo(roundPos, roundDepa);\n    const inputEvent = option?.event || eventInfo?.event || null;\n    const param = {\n      pos: moveTo.pos,\n      delta: moveTo.delta,\n      bounceRatio: this._getBounceRatio(moveTo.pos),\n      holding,\n      inputEvent,\n      isTrusted: !!inputEvent,\n      input: option?.input || eventInfo?.input || null,\n      set: inputEvent ? this._createUserControll(moveTo.pos) : () => {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    };\n    const result = this._axes.trigger(new ComponentEvent(\"change\", param));\n\n    if (inputEvent) {\n      axm.set((param.set() as { destPos: Axis; duration: number }).destPos);\n    }\n\n    return result;\n  }\n\n  /**\n   * This event is fired when animation starts.\n   * @ko 에니메이션이 시작할 때 발생한다.\n   * @name eg.Axes#animationStart\n   * @event\n   * @type {object}\n   * @property {Object.<string, number>} depaPos The coordinates when animation starts<ko>애니메이션이 시작 되었을 때의 좌표 </ko>\n   * @property {Object.<string, number>} destPos The coordinates to move to. If you change this value, you can run the animation<ko>이동할 좌표. 이값을 변경하여 애니메이션을 동작시킬수 있다</ko>\n   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>\n   * @property {Number} duration Duration of the animation (unit: ms). If you change this value, you can control the animation duration time.<ko>애니메이션 진행 시간(단위: ms). 이값을 변경하여 애니메이션의 이동시간을 조절할 수 있다.</ko>\n   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns 'null'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>\n   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>\n   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"release\", function(event) {\n   *   // event.depaPos\n   *   // event.destPos\n   *   // event.delta\n   *   // event.input\n   *   // event.inputEvent\n   *   // event.setTo\n   *   // event.isTrusted\n   *\n   *   // if you want to change the animation coordinates to move after the 'animationStart' event.\n   *   event.setTo({x: 10}, 2000);\n   * });\n   */\n  public triggerAnimationStart(param: AnimationParam): Axes {\n    const { roundPos, roundDepa } = this._getRoundPos(\n      param.destPos,\n      param.depaPos\n    );\n    param.destPos = roundPos;\n    param.depaPos = roundDepa;\n    param.setTo = this._createUserControll(param.destPos, param.duration);\n    return this._axes.trigger(\n      new ComponentEvent(\"animationStart\", param as OnAnimationStart)\n    );\n  }\n\n  /**\n   * This event is fired when animation ends.\n   * @ko 에니메이션이 끝났을 때 발생한다.\n   * @name eg.Axes#animationEnd\n   * @event\n   * @type {object}\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"animationEnd\", function(event) {\n   *   // event.isTrusted\n   * });\n   */\n  public triggerAnimationEnd(isTrusted: boolean = false) {\n    this._axes.trigger(\n      new ComponentEvent(\"animationEnd\", {\n        isTrusted,\n      })\n    );\n  }\n\n  /**\n   * This event is fired when all actions have been completed.\n   * @ko 에니메이션이 끝났을 때 발생한다.\n   * @name eg.Axes#finish\n   * @event\n   * @type {object}\n   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   *\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * }).on(\"finish\", function(event) {\n   *   // event.isTrusted\n   * });\n   */\n  public triggerFinish(isTrusted: boolean = false) {\n    this._axes.trigger(\n      new ComponentEvent(\"finish\", {\n        isTrusted,\n      })\n    );\n  }\n\n  public setAnimationManager(am: AnimationManager) {\n    this.am = am;\n  }\n\n  public destroy() {\n    this._axes.off();\n  }\n\n  private _createUserControll(pos: Axis, duration: number = 0) {\n    // to controll\n    const userControl = {\n      destPos: { ...pos },\n      duration,\n    };\n    return (\n      toPos?: Axis,\n      userDuration?: number\n    ): { destPos: Axis; duration: number } => {\n      if (toPos) {\n        userControl.destPos = { ...toPos };\n      }\n      if (userDuration !== undefined) {\n        userControl.duration = userDuration;\n      }\n      return userControl;\n    };\n  }\n\n  private _getRoundPos(pos: Axis, depaPos?: Axis) {\n    // round value if round exist\n    const roundUnit = this._axes.options.round;\n\n    // if (round == null) {\n    // \treturn {pos, depaPos}; // undefined, undefined\n    // }\n    return {\n      roundPos: roundNumbers(pos, roundUnit),\n      roundDepa: roundNumbers(depaPos, roundUnit),\n    };\n  }\n\n  private _getBounceRatio(pos: Axis): Axis {\n    return this._axes.axm.map(pos, (v, opt) => {\n      if (v < opt.range[0] && opt.bounce[0] !== 0) {\n        return (opt.range[0] - v) / opt.bounce[0];\n      } else if (v > opt.range[1] && opt.bounce[1] !== 0) {\n        return (v - opt.range[1]) / opt.bounce[1];\n      } else {\n        return 0;\n      }\n    });\n  }\n}\n","import { AxesOption } from \"./Axes\";\nexport class InterruptManager {\n  private _prevented = false; //  check whether the animation event was prevented\n  public constructor(private _options: AxesOption) {}\n\n  public isInterrupting() {\n    // when interruptable is 'true', return value is always 'true'.\n    return this._options.interruptable || this._prevented;\n  }\n\n  public isInterrupted() {\n    return !this._options.interruptable && this._prevented;\n  }\n\n  public setInterrupt(prevented) {\n    if (!this._options.interruptable) {\n      this._prevented = prevented;\n    }\n  }\n}\n","import { isOutside, getCirculatedPos } from \"./Coordinate\";\nimport { map, filter, every } from \"./utils\";\nimport { ObjectInterface } from \"./types\";\n\nexport interface Axis {\n  [key: string]: number;\n}\n\nexport interface AxisOption {\n  range?: number[];\n  bounce?: number | number[];\n  circular?: boolean | boolean[];\n}\n\nexport class AxisManager {\n  private _pos: Axis;\n  public constructor(private _axis: ObjectInterface<AxisOption>) {\n    this._complementOptions();\n    this._pos = Object.keys(this._axis).reduce((acc, v) => {\n      acc[v] = this._axis[v].range[0];\n      return acc;\n    }, {});\n  }\n\n  public getDelta(depaPos: Axis, destPos: Axis): Axis {\n    const fullDepaPos = this.get(depaPos);\n    return map(this.get(destPos), (v, k) => v - fullDepaPos[k]);\n  }\n\n  public get(axes?: string[] | Axis): Axis {\n    if (axes && Array.isArray(axes)) {\n      return axes.reduce((acc, v) => {\n        if (v && v in this._pos) {\n          acc[v] = this._pos[v];\n        }\n        return acc;\n      }, {});\n    } else {\n      return { ...this._pos, ...((axes || {}) as Axis) };\n    }\n  }\n\n  public moveTo(pos: Axis, depaPos: Axis = this._pos): { [key: string]: Axis } {\n    const delta = map(this._pos, (v, key) => {\n      return key in pos && key in depaPos ? pos[key] - depaPos[key] : 0;\n    });\n\n    this.set(\n      this.map(pos, (v, opt) =>\n        opt ? getCirculatedPos(v, opt.range, opt.circular as boolean[]) : 0\n      )\n    );\n    return {\n      pos: { ...this._pos },\n      delta,\n    };\n  }\n\n  public set(pos: Axis) {\n    for (const k in pos) {\n      if (k && k in this._pos) {\n        this._pos[k] = pos[k];\n      }\n    }\n  }\n\n  public every(\n    pos: Axis,\n    callback: (value: number, options: AxisOption, key: string) => boolean\n  ): boolean {\n    const axisOptions = this._axis;\n\n    return every(pos, (value, key) => callback(value, axisOptions[key], key));\n  }\n\n  public filter(\n    pos: Axis,\n    callback: (value: number, options: AxisOption, key: string) => boolean\n  ): Axis {\n    const axisOptions = this._axis;\n\n    return filter(pos, (value, key) => callback(value, axisOptions[key], key));\n  }\n\n  public map<U>(\n    pos: Axis,\n    callback: (value: number, options: AxisOption, key: string) => U\n  ) {\n    const axisOptions = this._axis;\n\n    return map<number, U>(pos, (value, key) =>\n      callback(value, axisOptions[key], key)\n    );\n  }\n\n  public isOutside(axes?: string[]) {\n    return !this.every(\n      axes ? this.get(axes) : this._pos,\n      (v, opt) => !isOutside(v, opt.range)\n    );\n  }\n\n  public getAxisOptions(key: string) {\n    return this._axis[key];\n  }\n\n  /**\n   * set up 'css' expression\n   * @private\n   */\n  private _complementOptions() {\n    Object.keys(this._axis).forEach((axis) => {\n      this._axis[axis] = {\n        ...{\n          range: [0, 100],\n          bounce: [0, 0],\n          circular: [false, false],\n        },\n        ...this._axis[axis],\n      };\n\n      [\"bounce\", \"circular\"].forEach((v) => {\n        const axisOption = this._axis;\n        const key = axisOption[axis][v];\n\n        if (/string|number|boolean/.test(typeof key)) {\n          axisOption[axis][v] = [key, key];\n        }\n      });\n    });\n  }\n}\n","import { ExtendedEvent, InputEventType } from \"../types\";\nimport { getAngle } from \"../utils\";\nimport { window } from \"../browser\";\n\nexport const SUPPORT_TOUCH = \"ontouchstart\" in window;\nexport const SUPPORT_POINTER = \"PointerEvent\" in window;\nexport const SUPPORT_MSPOINTER = \"MSPointerEvent\" in window;\nexport const SUPPORT_POINTER_EVENTS = SUPPORT_POINTER || SUPPORT_MSPOINTER;\n\nexport abstract class EventInput {\n  public prevEvent: ExtendedEvent;\n\n  public abstract onEventStart(event: InputEventType): ExtendedEvent;\n\n  public abstract onEventMove(event: InputEventType): ExtendedEvent;\n\n  public abstract onEventEnd(event: InputEventType): void;\n\n  public abstract getTouches(event: InputEventType): number;\n\n  protected abstract _getScale(event: InputEventType): number;\n\n  protected abstract _getCenter(event: InputEventType): {\n    x: number;\n    y: number;\n  };\n\n  protected abstract _getMovement(event: InputEventType): {\n    x: number;\n    y: number;\n  };\n\n  public extendEvent(event: InputEventType): ExtendedEvent {\n    const prevEvent = this.prevEvent;\n    const center = this._getCenter(event);\n    const movement = prevEvent ? this._getMovement(event) : { x: 0, y: 0 };\n    const scale = prevEvent ? this._getScale(event) : 1;\n    const angle = prevEvent\n      ? getAngle(center.x - prevEvent.center.x, center.y - prevEvent.center.y)\n      : 0;\n    const deltaX = prevEvent ? prevEvent.deltaX + movement.x : movement.x;\n    const deltaY = prevEvent ? prevEvent.deltaY + movement.y : movement.y;\n    const offsetX = prevEvent ? deltaX - prevEvent.deltaX : 0;\n    const offsetY = prevEvent ? deltaY - prevEvent.deltaY : 0;\n    const velocityX = prevEvent\n      ? offsetX / (event.timeStamp - prevEvent.srcEvent.timeStamp)\n      : 0;\n    const velocityY = prevEvent\n      ? offsetY / (event.timeStamp - prevEvent.srcEvent.timeStamp)\n      : 0;\n    return {\n      srcEvent: event,\n      scale,\n      angle,\n      center,\n      deltaX,\n      deltaY,\n      offsetX,\n      offsetY,\n      velocityX,\n      velocityY,\n      preventSystemEvent: true,\n    };\n  }\n\n  protected _getDistance(\n    start: Touch | PointerEvent,\n    end: Touch | PointerEvent\n  ): number {\n    const x = end.clientX - start.clientX;\n    const y = end.clientY - start.clientY;\n    return Math.sqrt(x * x + y * y);\n  }\n}\n","import { InputEventType, ExtendedEvent } from \"../types\";\n\nimport { EventInput } from \"./EventInput\";\n\nexport class MouseEventInput extends EventInput {\n  public readonly start = [\"mousedown\"];\n  public readonly move = [\"mousemove\"];\n  public readonly end = [\"mouseup\"];\n\n  public onEventStart(event: InputEventType): ExtendedEvent {\n    return this.extendEvent(event);\n  }\n\n  public onEventMove(event: InputEventType): ExtendedEvent {\n    return this.extendEvent(event);\n  }\n\n  public onEventEnd(): void {\n    return;\n  }\n\n  public getTouches(): number {\n    return 0;\n  }\n\n  protected _getScale(): number {\n    return 1;\n  }\n\n  protected _getCenter(event: MouseEvent): { x: number; y: number } {\n    return {\n      x: event.clientX,\n      y: event.clientY,\n    };\n  }\n\n  protected _getMovement(event: MouseEvent): { x: number; y: number } {\n    const prev = this.prevEvent.srcEvent as MouseEvent;\n    return {\n      x: event.pageX - prev.pageX,\n      y: event.pageY - prev.pageY,\n    };\n  }\n}\n","import { InputEventType, ExtendedEvent } from \"../types\";\n\nimport { EventInput } from \"./EventInput\";\n\nexport class TouchEventInput extends EventInput {\n  public readonly start = [\"touchstart\"];\n  public readonly move = [\"touchmove\"];\n  public readonly end = [\"touchend\", \"touchcancel\"];\n\n  private _firstTouch: TouchEvent;\n\n  public onEventStart(event: InputEventType): ExtendedEvent {\n    this._firstTouch = event as TouchEvent;\n    return this.extendEvent(event);\n  }\n\n  public onEventMove(event: InputEventType): ExtendedEvent {\n    return this.extendEvent(event);\n  }\n\n  public onEventEnd(): void {\n    return;\n  }\n\n  public getTouches(event: InputEventType): number {\n    return (event as TouchEvent).touches.length;\n  }\n\n  protected _getScale(event: TouchEvent): number {\n    if (event.touches.length !== 2) {\n      return null; // TODO: consider calculating non-pinch gesture scale\n    }\n    return (\n      this._getDistance(event.touches[0], event.touches[1]) /\n      this._getDistance(\n        this._firstTouch.touches[0],\n        this._firstTouch.touches[1]\n      )\n    );\n  }\n\n  protected _getCenter(event: TouchEvent): { x: number; y: number } {\n    return {\n      x: event.touches[0].clientX,\n      y: event.touches[0].clientY,\n    };\n  }\n\n  protected _getMovement(event: TouchEvent): { x: number; y: number } {\n    const prev = this.prevEvent.srcEvent as TouchEvent;\n    if (event.touches[0].identifier !== prev.touches[0].identifier) {\n      return {\n        x: 0,\n        y: 0,\n      };\n    }\n    return {\n      x: event.touches[0].pageX - prev.touches[0].pageX,\n      y: event.touches[0].pageY - prev.touches[0].pageY,\n    };\n  }\n}\n","import { InputEventType, ExtendedEvent } from \"../types\";\n\nimport { EventInput, SUPPORT_POINTER } from \"./EventInput\";\n\nexport class PointerEventInput extends EventInput {\n  public readonly start = SUPPORT_POINTER ? [\"pointerdown\"] : [\"MSPointerDown\"];\n  public readonly move = SUPPORT_POINTER ? [\"pointermove\"] : [\"MSPointerMove\"];\n  public readonly end = SUPPORT_POINTER\n    ? [\"pointerup\", \"pointercancel\"]\n    : [\"MSPointerUp\", \"MSPointerCancel\"];\n\n  // store first, recent inputs for each event id\n  private _firstInputs: PointerEvent[] = [];\n  private _recentInputs: PointerEvent[] = [];\n\n  public onEventStart(event: InputEventType): ExtendedEvent {\n    this._updatePointerEvent(event as PointerEvent);\n    return this.extendEvent(event);\n  }\n\n  public onEventMove(event: InputEventType): ExtendedEvent {\n    this._updatePointerEvent(event as PointerEvent);\n    return this.extendEvent(event);\n  }\n\n  public onEventEnd(event: InputEventType): void {\n    this._removePointerEvent(event as PointerEvent);\n  }\n\n  public getTouches(): number {\n    return this._recentInputs.length;\n  }\n\n  protected _getScale(): number {\n    if (this._recentInputs.length !== 2) {\n      return null; // TODO: consider calculating non-pinch gesture scale\n    }\n    return (\n      this._getDistance(this._recentInputs[0], this._recentInputs[1]) /\n      this._getDistance(this._firstInputs[0], this._firstInputs[1])\n    );\n  }\n\n  protected _getCenter(event: PointerEvent): { x: number; y: number } {\n    return {\n      x: event.clientX,\n      y: event.clientY,\n    };\n  }\n\n  protected _getMovement(event: PointerEvent): { x: number; y: number } {\n    const prev = this.prevEvent.srcEvent as PointerEvent;\n    if (event.pointerId !== prev.pointerId) {\n      return {\n        x: 0,\n        y: 0,\n      };\n    }\n    return {\n      x: event.pageX - prev.pageX,\n      y: event.pageY - prev.pageY,\n    };\n  }\n\n  private _updatePointerEvent(event: PointerEvent) {\n    let addFlag = false;\n    this._recentInputs.forEach((e, i) => {\n      if (e.pointerId === event.pointerId) {\n        addFlag = true;\n        this._recentInputs[i] = event;\n      }\n    });\n    if (!addFlag) {\n      this._firstInputs.push(event);\n      this._recentInputs.push(event);\n    }\n  }\n\n  private _removePointerEvent(event: PointerEvent) {\n    this._firstInputs = this._firstInputs.filter(\n      (x) => x.pointerId !== event.pointerId\n    );\n    this._recentInputs = this._recentInputs.filter(\n      (x) => x.pointerId !== event.pointerId\n    );\n  }\n}\n","import { InputEventType, ExtendedEvent } from \"../types\";\n\nimport { EventInput } from \"./EventInput\";\n\nexport class TouchMouseEventInput extends EventInput {\n  public readonly start = [\"mousedown\", \"touchstart\"];\n  public readonly move = [\"mousemove\", \"touchmove\"];\n  public readonly end = [\"mouseup\", \"touchend\", \"touchcancel\"];\n\n  private _firstTouch: TouchEvent;\n\n  public onEventStart(event: InputEventType): ExtendedEvent {\n    this._firstTouch = event instanceof TouchEvent ? event : null;\n    return this.extendEvent(event);\n  }\n\n  public onEventMove(event: InputEventType): ExtendedEvent {\n    return this.extendEvent(event);\n  }\n\n  public onEventEnd(): void {\n    return;\n  }\n\n  public getTouches(event: InputEventType): number {\n    return event instanceof TouchEvent ? event.touches.length : 0;\n  }\n\n  protected _getScale(event: MouseEvent | TouchEvent): number {\n    if (\n      !this._firstTouch ||\n      (event instanceof TouchEvent && event.touches.length !== 2)\n    ) {\n      return 1; // TODO: consider calculating non-pinch gesture scale\n    }\n    return event instanceof TouchEvent\n      ? this._getDistance(event.touches[0], event.touches[1]) /\n          this._getDistance(\n            this._firstTouch.touches[0],\n            this._firstTouch.touches[1]\n          )\n      : this.prevEvent.scale;\n  }\n\n  protected _getCenter(event: MouseEvent | TouchEvent): {\n    x: number;\n    y: number;\n  } {\n    return event instanceof TouchEvent\n      ? { x: event.touches[0].clientX, y: event.touches[0].clientY }\n      : { x: event.clientX, y: event.clientY };\n  }\n\n  protected _getMovement(event: MouseEvent | TouchEvent): {\n    x: number;\n    y: number;\n  } {\n    const prev = this.prevEvent.srcEvent;\n    const [nextSpot, prevSpot] = [event, prev].map((e) => {\n      return {\n        id: e instanceof TouchEvent ? e.touches[0].identifier : null,\n        x: e instanceof TouchEvent ? e.touches[0].pageX : e.pageX,\n        y: e instanceof TouchEvent ? e.touches[0].pageY : e.pageY,\n      };\n    });\n    return nextSpot.id === prevSpot.id\n      ? { x: nextSpot.x - prevSpot.x, y: nextSpot.y - prevSpot.y }\n      : { x: 0, y: 0 };\n  }\n}\n","import { InterruptManager } from \"./InterruptManager\";\nimport { IInputType, IInputTypeObserver, toAxis } from \"./inputType/InputType\";\nimport { EventManager, ChangeEventOption } from \"./EventManager\";\nimport { AxisManager, Axis } from \"./AxisManager\";\nimport { AnimationManager } from \"./AnimationManager\";\nimport { AxesOption } from \"./Axes\";\nimport { isOutside, getInsidePosition, getCirculatedPos } from \"./Coordinate\";\nimport { map, equal } from \"./utils\";\nimport { AnimationParam } from \"./types\";\n\nexport class InputObserver implements IInputTypeObserver {\n  public options: AxesOption;\n  private _itm: InterruptManager;\n  private _em: EventManager;\n  private _axm: AxisManager;\n  private _am: AnimationManager;\n  private _isOutside = false;\n  private _moveDistance: Axis = null;\n  private _isStopped = false;\n  public constructor({\n    options,\n    itm,\n    em,\n    axm,\n    am,\n  }: {\n    options: AxesOption;\n    itm: InterruptManager;\n    em: EventManager;\n    axm: AxisManager;\n    am: AnimationManager;\n  }) {\n    this.options = options;\n    this._itm = itm;\n    this._em = em;\n    this._axm = axm;\n    this._am = am;\n  }\n\n  public get(input: IInputType): Axis {\n    return this._axm.get(input.axes);\n  }\n\n  public hold(input: IInputType, event) {\n    if (this._itm.isInterrupted() || !input.axes.length) {\n      return;\n    }\n    const changeOption: ChangeEventOption = {\n      input,\n      event,\n    };\n    this._isStopped = false;\n    this._itm.setInterrupt(true);\n    this._am.stopAnimation(input.axes, changeOption);\n    if (!this._moveDistance) {\n      this._em.triggerHold(this._axm.get(), changeOption);\n    }\n    this._isOutside = this._axm.isOutside(input.axes);\n    this._moveDistance = this._axm.get(input.axes);\n  }\n\n  public change(input: IInputType, event, offset: Axis, useDuration?: boolean) {\n    if (\n      this._isStopped ||\n      !this._itm.isInterrupting() ||\n      this._axm.every(offset, (v) => v === 0)\n    ) {\n      return;\n    }\n    let depaPos: Axis = this._moveDistance || this._axm.get(input.axes);\n    let destPos: Axis;\n\n    // for outside logic\n    destPos = map(depaPos, (v, k) => v + (offset[k] || 0));\n    if (this._moveDistance) {\n      this._moveDistance = this._axm.map(destPos, (v, { circular, range }) =>\n        circular && (circular[0] || circular[1])\n          ? getCirculatedPos(v, range, circular as boolean[])\n          : v\n      );\n    }\n    // from outside to inside\n    if (\n      this._isOutside &&\n      this._axm.every(depaPos, (v, opt) => !isOutside(v, opt.range))\n    ) {\n      this._isOutside = false;\n    }\n    depaPos = this._atOutside(depaPos);\n    destPos = this._atOutside(destPos);\n    const changeOption: ChangeEventOption = {\n      input,\n      event,\n    };\n    if (useDuration) {\n      const duration = this._am.getDuration(destPos, depaPos);\n      this._am.stopAnimation(input.axes, changeOption);\n      this._am.animateTo(destPos, duration, changeOption);\n    } else {\n      const isCanceled = !this._em.triggerChange(\n        destPos,\n        false,\n        depaPos,\n        changeOption,\n        true\n      );\n      if (isCanceled) {\n        this._isStopped = true;\n        this._moveDistance = null;\n        this._am.finish(false);\n      }\n    }\n  }\n\n  public release(\n    input: IInputType,\n    event,\n    velocity: number[],\n    inputDuration?: number\n  ) {\n    if (this._isStopped || !this._itm.isInterrupting() || !this._moveDistance) {\n      return;\n    }\n    const pos: Axis = this._axm.get(input.axes);\n    const depaPos: Axis = this._axm.get();\n    const displacement = this._am.getDisplacement(velocity);\n    const offset = toAxis(input.axes, displacement);\n    let destPos: Axis = this._axm.get(\n      this._axm.map(offset, (v, opt, k) => {\n        if (opt.circular && (opt.circular[0] || opt.circular[1])) {\n          return pos[k] + v;\n        } else {\n          return getInsidePosition(\n            pos[k] + v,\n            opt.range,\n            opt.circular as boolean[],\n            opt.bounce as number[]\n          );\n        }\n      })\n    );\n    const duration = this._am.getDuration(destPos, pos, inputDuration);\n\n    if (duration === 0) {\n      destPos = { ...depaPos };\n    }\n    // prepare params\n    const param: AnimationParam = {\n      depaPos,\n      destPos,\n      duration,\n      delta: this._axm.getDelta(depaPos, destPos),\n      inputEvent: event,\n      input,\n      isTrusted: true,\n    };\n    this._em.triggerRelease(param);\n    this._moveDistance = null;\n\n    // to contol\n    const userWish = this._am.getUserControl(param);\n    const isEqual = equal(userWish.destPos, depaPos);\n    const changeOption: ChangeEventOption = {\n      input,\n      event,\n    };\n    if (isEqual || userWish.duration === 0) {\n      if (!isEqual) {\n        this._em.triggerChange(\n          userWish.destPos,\n          false,\n          depaPos,\n          changeOption,\n          true\n        );\n      }\n      this._itm.setInterrupt(false);\n      if (this._axm.isOutside()) {\n        this._am.restore(changeOption);\n      } else {\n        this._em.triggerFinish(true);\n      }\n    } else {\n      this._am.animateTo(userWish.destPos, userWish.duration, changeOption);\n    }\n  }\n\n  // when move pointer is held in outside\n  private _atOutside(pos: Axis) {\n    if (this._isOutside) {\n      return this._axm.map(pos, (v, opt) => {\n        const tn = opt.range[0] - (opt.bounce[0] as number);\n        const tx = opt.range[1] + (opt.bounce[1] as number);\n        return v > tx ? tx : v < tn ? tn : v;\n      });\n    } else {\n      return this._axm.map(pos, (v, opt) => {\n        const min = opt.range[0];\n        const max = opt.range[1];\n        const out = opt.bounce;\n        const circular = opt.circular;\n\n        if (circular && (circular[0] || circular[1])) {\n          return v;\n        } else if (v < min) {\n          // left\n          return min - this._am.interpolate(min - v, out[0] as number);\n        } else if (v > max) {\n          // right\n          return max + this._am.interpolate(v - max, out[1] as number);\n        }\n        return v;\n      });\n    }\n  }\n}\n","import Component from \"@egjs/component\";\n\nimport { AnimationManager } from \"./AnimationManager\";\nimport { EventManager } from \"./EventManager\";\nimport { InterruptManager } from \"./InterruptManager\";\nimport { AxisManager, AxisOption, Axis } from \"./AxisManager\";\nimport { InputObserver } from \"./InputObserver\";\nimport {\n  TRANSFORM,\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n} from \"./const\";\nimport { IInputType } from \"./inputType/InputType\";\nimport { AxesEvents, ObjectInterface, UpdateAnimationOption } from \"./types\";\n\nexport interface AxesOption {\n  easing?: (x: number) => number;\n  maximumDuration?: number;\n  minimumDuration?: number;\n  deceleration?: number;\n  interruptable?: boolean;\n  round?: number;\n}\n\n/**\n * @typedef {Object} AxisOption The Axis information. The key of the axis specifies the name to use as the logical virtual coordinate system.\n * @ko 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.\n * @property {Number[]} [range] The coordinate of range <ko>좌표 범위</ko>\n * @property {Number} [range.0=0] The coordinate of the minimum <ko>최소 좌표</ko>\n * @property {Number} [range.1=0] The coordinate of the maximum <ko>최대 좌표</ko>\n * @property {Number[]} [bounce] The size of bouncing area. The coordinates can exceed the coordinate area as much as the bouncing area based on user action. If the coordinates does not exceed the bouncing area when an element is dragged, the coordinates where bouncing effects are applied are retuned back into the coordinate area<ko>바운스 영역의 크기. 사용자의 동작에 따라 좌표가 좌표 영역을 넘어 바운스 영역의 크기만큼 더 이동할 수 있다. 사용자가 끌어다 놓는 동작을 했을 때 좌표가 바운스 영역에 있으면, 바운스 효과가 적용된 좌표가 다시 좌표 영역 안으로 들어온다</ko>\n * @property {Number} [bounce.0=0] The size of coordinate of the minimum area <ko>최소 좌표 바운스 영역의 크기</ko>\n * @property {Number} [bounce.1=0] The size of coordinate of the maximum area <ko>최대 좌표 바운스 영역의 크기</ko>\n * @property {Boolean[]} [circular] Indicates whether a circular element is available. If it is set to \"true\" and an element is dragged outside the coordinate area, the element will appear on the other side.<ko>순환 여부. 'true'로 설정한 방향의 좌표 영역 밖으로 엘리먼트가 이동하면 반대 방향에서 엘리먼트가 나타난다</ko>\n * @property {Boolean} [circular.0=false] Indicates whether to circulate to the coordinate of the minimum <ko>최소 좌표 방향의 순환 여부</ko>\n * @property {Boolean} [circular.1=false] Indicates whether to circulate to the coordinate of the maximum <ko>최대 좌표 방향의 순환 여부</ko>\n **/\n\n/**\n * @typedef {Object} AxesOption The option object of the eg.Axes module\n * @ko eg.Axes 모듈의 옵션 객체\n * @property {Function} [easing=easing.easeOutCubic] The easing function to apply to an animation <ko>애니메이션에 적용할 easing 함수</ko>\n * @property {Number} [maximumDuration=Infinity] Maximum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최대 좌표 이동 시간</ko>\n * @property {Number} [minimumDuration=0] Minimum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최소 좌표 이동 시간</ko>\n * @property {Number} [deceleration=0.0006] Deceleration of the animation where acceleration is manually enabled by user. A higher value indicates shorter running time. <ko>사용자의 동작으로 가속도가 적용된 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다</ko>\n * @property {Boolean} [interruptable=true] Indicates whether an animation is interruptible.<br>- true: It can be paused or stopped by user action or the API.<br>- false: It cannot be paused or stopped by user action or the API while it is running.<ko>진행 중인 애니메이션 중지 가능 여부.<br>- true: 사용자의 동작이나 API로 애니메이션을 중지할 수 있다.<br>- false: 애니메이션이 진행 중일 때는 사용자의 동작이나 API가 적용되지 않는다</ko>\n * @property {Number} [round = null] Rounding unit. For example, 0.1 rounds to 0.1 decimal point(6.1234 => 6.1), 5 rounds to 5 (93 => 95) <br>[Details](https://github.com/naver/egjs-axes/wiki/round-option)<ko>반올림 단위. 예를 들어 0.1 은 소숫점 0.1 까지 반올림(6.1234 => 6.1), 5 는 5 단위로 반올림(93 => 95).<br>[상세내용](https://github.com/naver/egjs-axes/wiki/round-option)</ko>\n **/\n\n/**\n * @class eg.Axes\n * @classdesc A module used to change the information of user action entered by various input devices such as touch screen or mouse into the logical virtual coordinates. You can easily create a UI that responds to user actions.\n * @ko 터치 입력 장치나 마우스와 같은 다양한 입력 장치를 통해 전달 받은 사용자의 동작을 논리적인 가상 좌표로 변경하는 모듈이다. 사용자 동작에 반응하는 UI를 손쉽게 만들수 있다.\n * @extends eg.Component\n *\n * @param {Object.<string, AxisOption>} axis Axis information managed by eg.Axes. The key of the axis specifies the name to use as the logical virtual coordinate system.  <ko>eg.Axes가 관리하는 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.</ko>\n * @param {AxesOption} [options] The option object of the eg.Axes module<ko>eg.Axes 모듈의 옵션 객체</ko>\n * @param {Object.<string, number>} [startPos] The coordinates to be moved when creating an instance. not triggering change event.<ko>인스턴스 생성시 이동할 좌표, change 이벤트는 발생하지 않음.</ko>\n *\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.3+ (except 3.x)\"}\n * @example\n *\n * // 1. Initialize eg.Axes\n * const axes = new eg.Axes({\n *\tsomething1: {\n *\t\trange: [0, 150],\n *\t\tbounce: 50\n *\t},\n *\tsomething2: {\n *\t\trange: [0, 200],\n *\t\tbounce: 100\n *\t},\n *\tsomethingN: {\n *\t\trange: [1, 10],\n *\t}\n * }, {\n *  deceleration : 0.0024\n * });\n *\n * // 2. attach event handler\n * axes.on({\n *\t\"hold\" : function(evt) {\n *\t},\n *\t\"release\" : function(evt) {\n *\t},\n *\t\"animationStart\" : function(evt) {\n *\t},\n *\t\"animationEnd\" : function(evt) {\n *\t},\n *\t\"change\" : function(evt) {\n *\t}\n * });\n *\n * // 3. Initialize inputTypes\n * const panInputArea = new eg.Axes.PanInput(\"#area\", {\n *\tscale: [0.5, 1]\n * });\n * const panInputHmove = new eg.Axes.PanInput(\"#hmove\");\n * const panInputVmove = new eg.Axes.PanInput(\"#vmove\");\n * const pinchInputArea = new eg.Axes.PinchInput(\"#area\", {\n *\tscale: 1.5\n * });\n *\n * // 4. Connect eg.Axes and InputTypes\n * // [PanInput] When the mouse or touchscreen is down and moved.\n * // Connect the 'something2' axis to the mouse or touchscreen x position and\n * // connect the 'somethingN' axis to the mouse or touchscreen y position.\n * axes.connect([\"something2\", \"somethingN\"], panInputArea); // or axes.connect(\"something2 somethingN\", panInputArea);\n *\n * // Connect only one 'something1' axis to the mouse or touchscreen x position.\n * axes.connect([\"something1\"], panInputHmove); // or axes.connect(\"something1\", panInputHmove);\n *\n * // Connect only one 'something2' axis to the mouse or touchscreen y position.\n * axes.connect([\"\", \"something2\"], panInputVmove); // or axes.connect(\" something2\", panInputVmove);\n *\n * // [PinchInput] Connect 'something2' axis when two pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * axes.connect(\"something2\", pinchInputArea);\n */\nexport default class Axes extends Component<AxesEvents> {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @name VERSION\n   * @static\n   * @type {String}\n   * @example\n   * eg.Axes.VERSION;  // ex) 3.3.3\n   * @memberof eg.Axes\n   */\n  public static VERSION = \"#__VERSION__#\";\n  /* eslint-disable */\n  // for tree shaking\n  public static PanInput;\n  public static PinchInput;\n  public static WheelInput;\n  public static MoveKeyInput;\n  public static RotatePanInput;\n  /* eslint-enable */\n\n  /**\n   * @name eg.Axes.TRANSFORM\n   * @desc Returns the transform attribute with CSS vendor prefixes.\n   * @ko CSS vendor prefixes를 붙인 transform 속성을 반환한다.\n   *\n   * @constant\n   * @type {String}\n   * @example\n   * eg.Axes.TRANSFORM; // \"transform\" or \"webkitTransform\"\n   */\n  public static TRANSFORM = TRANSFORM;\n  /**\n   * @name eg.Axes.DIRECTION_NONE\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_NONE = DIRECTION_NONE;\n  /**\n   * @name eg.Axes.DIRECTION_LEFT\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_LEFT = DIRECTION_LEFT;\n  /**\n   * @name eg.Axes.DIRECTION_RIGHT\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_RIGHT = DIRECTION_RIGHT;\n  /**\n   * @name eg.Axes.DIRECTION_UP\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_UP = DIRECTION_UP;\n  /**\n   * @name eg.Axes.DIRECTION_DOWN\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_DOWN = DIRECTION_DOWN;\n  /**\n   * @name eg.Axes.DIRECTION_HORIZONTAL\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  /**\n   * @name eg.Axes.DIRECTION_VERTICAL\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  /**\n   * @name eg.Axes.DIRECTION_ALL\n   * @constant\n   * @type {Number}\n   */\n  public static DIRECTION_ALL = DIRECTION_ALL;\n\n  public options: AxesOption;\n  public em: EventManager;\n  public axm: AxisManager;\n  public itm: InterruptManager;\n  public am: AnimationManager;\n  public io: InputObserver;\n  private _inputs: IInputType[] = [];\n\n  public constructor(\n    public axis: ObjectInterface<AxisOption> = {},\n    options: AxesOption = {},\n    startPos?: Axis\n  ) {\n    super();\n    this.options = {\n      ...{\n        easing: (x) => {\n          return 1 - Math.pow(1 - x, 3);\n        },\n        interruptable: true,\n        maximumDuration: Infinity,\n        minimumDuration: 0,\n        deceleration: 0.0006,\n        round: null,\n      },\n      ...options,\n    };\n\n    this.itm = new InterruptManager(this.options);\n    this.axm = new AxisManager(this.axis);\n    this.em = new EventManager(this);\n    this.am = new AnimationManager(this);\n    this.io = new InputObserver(this);\n    this.em.setAnimationManager(this.am);\n    if (startPos) {\n      this.em.triggerChange(startPos);\n    }\n  }\n\n  /**\n   * Connect the axis of eg.Axes to the inputType.\n   * @ko eg.Axes의 축과 inputType을 연결한다\n   * @method eg.Axes#connect\n   * @param {(String[]|String)} axes The name of the axis to associate with inputType <ko>inputType과 연결할 축의 이름</ko>\n   * @param {Object} inputType The inputType instance to associate with the axis of eg.Axes <ko>eg.Axes의 축과 연결할 inputType 인스턴스<ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   }\n   * });\n   *\n   * axes.connect(\"x\", new eg.Axes.PanInput(\"#area1\"))\n   *    .connect(\"x xOther\", new eg.Axes.PanInput(\"#area2\"))\n   *    .connect(\" xOther\", new eg.Axes.PanInput(\"#area3\"))\n   *    .connect([\"x\"], new eg.Axes.PanInput(\"#area4\"))\n   *    .connect([\"xOther\", \"x\"], new eg.Axes.PanInput(\"#area5\"))\n   *    .connect([\"\", \"xOther\"], new eg.Axes.PanInput(\"#area6\"));\n   */\n  public connect(axes: string[] | string, inputType: IInputType) {\n    let mapped: string[];\n    if (typeof axes === \"string\") {\n      mapped = axes.split(\" \");\n    } else {\n      mapped = axes.concat();\n    }\n\n    // check same instance\n    if (~this._inputs.indexOf(inputType)) {\n      this.disconnect(inputType);\n    }\n\n    inputType.mapAxes(mapped);\n    inputType.connect(this.io);\n    this._inputs.push(inputType);\n    return this;\n  }\n\n  /**\n   * Disconnect the axis of eg.Axes from the inputType.\n   * @ko eg.Axes의 축과 inputType의 연결을 끊는다.\n   * @method eg.Axes#disconnect\n   * @param {Object} [inputType] An inputType instance associated with the axis of eg.Axes <ko>eg.Axes의 축과 연결한 inputType 인스턴스<ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   }\n   * });\n   *\n   * const input1 = new eg.Axes.PanInput(\"#area1\");\n   * const input2 = new eg.Axes.PanInput(\"#area2\");\n   * const input3 = new eg.Axes.PanInput(\"#area3\");\n   *\n   * axes.connect(\"x\", input1);\n   *    .connect(\"x xOther\", input2)\n   *    .connect([\"xOther\", \"x\"], input3);\n   *\n   * axes.disconnect(input1); // disconnects input1\n   * axes.disconnect(); // disconnects all of them\n   */\n  public disconnect(inputType?: IInputType) {\n    if (inputType) {\n      const index = this._inputs.indexOf(inputType);\n\n      if (index >= 0) {\n        this._inputs[index].disconnect();\n        this._inputs.splice(index, 1);\n      }\n    } else {\n      this._inputs.forEach((v) => v.disconnect());\n      this._inputs = [];\n    }\n    return this;\n  }\n\n  /**\n   * Returns the current position of the coordinates.\n   * @ko 좌표의 현재 위치를 반환한다\n   * @method eg.Axes#get\n   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>\n   * @return {Object.<string, number>} Axis coordinate information <ko>축 좌표 정보</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   },\n   * \t \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.get(); // {\"x\": 0, \"xOther\": -100, \"zoom\": 50}\n   * axes.get([\"x\", \"zoom\"]); // {\"x\": 0, \"zoom\": 50}\n   */\n  public get(axes?: string[]) {\n    return this.axm.get(axes);\n  }\n\n  /**\n   * Moves an axis to specific coordinates.\n   * @ko 좌표를 이동한다.\n   * @method eg.Axes#setTo\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   },\n   * \t \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.setTo({\"x\": 30, \"zoom\": 60});\n   * axes.get(); // {\"x\": 30, \"xOther\": -100, \"zoom\": 60}\n   *\n   * axes.setTo({\"x\": 100, \"xOther\": 60}, 1000); // animatation\n   *\n   * // after 1000 ms\n   * axes.get(); // {\"x\": 100, \"xOther\": 60, \"zoom\": 60}\n   */\n  public setTo(pos: Axis, duration = 0) {\n    this.am.setTo(pos, duration);\n    return this;\n  }\n\n  /**\n   * Moves an axis from the current coordinates to specific coordinates.\n   * @ko 현재 좌표를 기준으로 좌표를 이동한다.\n   * @method eg.Axes#setBy\n   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   },\n   * \t \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.setBy({\"x\": 30, \"zoom\": 10});\n   * axes.get(); // {\"x\": 30, \"xOther\": -100, \"zoom\": 60}\n   *\n   * axes.setBy({\"x\": 70, \"xOther\": 60}, 1000); // animatation\n   *\n   * // after 1000 ms\n   * axes.get(); // {\"x\": 100, \"xOther\": -40, \"zoom\": 60}\n   */\n  public setBy(pos: Axis, duration = 0) {\n    this.am.setBy(pos, duration);\n    return this;\n  }\n\n  /**\n   * Stop an animation in progress.\n   * @ko 재생 중인 애니메이션을 정지한다.\n   * @method eg.Axes#stopAnimation\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   * });\n   *\n   * axes.setTo({\"x\": 10}, 1000); // start animatation\n   *\n   * // after 500 ms\n   * axes.stopAnimation(); // stop animation during movement.\n   */\n  public stopAnimation() {\n    this.am.stopAnimation(Object.keys(this.axm.get()));\n    return this;\n  }\n\n  /**\n   * Change the destination of an animation in progress.\n   * @ko 재생 중인 애니메이션의 목적지와 진행 시간을 변경한다.\n   * @method eg.Axes#updateAnimation\n   * @param {UpdateAnimationOption} pos The coordinate to move to <ko>이동할 좌표</ko>\n   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 200]\n   *   },\n   *   \"y\": {\n   *      range: [0, 200]\n   *   }\n   * });\n   *\n   * axes.setTo({\"x\": 50, \"y\": 50}, 1000); // trigger animation by setTo\n   *\n   * // after 500 ms\n   * axes.updateAnimation({destPos: {\"x\": 100, \"y\": 100}}); // animation will end after 500 ms, at {\"x\": 100, \"y\": 100}\n   *\n   * // after 500 ms\n   * axes.setTo({\"x\": 50, \"y\": 50}, 1000); // trigger animation by setTo\n   *\n   * // after 700 ms\n   * axes.updateAnimation({destPos: {\"x\": 100, \"y\": 100}, duration: 1500, restart: true}); // this works same as axes.setTo({\"x\": 100, \"y\": 100}, 800) since restart is true.\n   */\n  public updateAnimation(options: UpdateAnimationOption) {\n    this.am.updateAnimation(options);\n    return this;\n  }\n\n  /**\n   * Returns whether there is a coordinate in the bounce area of ​​the target axis.\n   * @ko 대상 축 중 bounce영역에 좌표가 존재하는지를 반환한다\n   * @method eg.Axes#isBounceArea\n   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>\n   * @return {Boolen} Whether the bounce area exists. <ko>bounce 영역 존재 여부</ko>\n   * @example\n   * const axes = new eg.Axes({\n   *   \"x\": {\n   *      range: [0, 100]\n   *   },\n   *   \"xOther\": {\n   *      range: [-100, 100]\n   *   },\n   * \t \"zoom\": {\n   *      range: [50, 30]\n   *   }\n   * });\n   *\n   * axes.isBounceArea([\"x\"]);\n   * axes.isBounceArea([\"x\", \"zoom\"]);\n   * axes.isBounceArea();\n   */\n  public isBounceArea(axes?: string[]) {\n    return this.axm.isOutside(axes);\n  }\n\n  /**\n   * Destroys properties, and events used in a module and disconnect all connections to inputTypes.\n   * @ko 모듈에 사용한 속성, 이벤트를 해제한다. 모든 inputType과의 연결을 끊는다.\n   * @method eg.Axes#destroy\n   */\n  public destroy() {\n    this.disconnect();\n    this.em.destroy();\n  }\n}\n","import { ExtendedEvent } from \"../types\";\nimport Axes from \"../Axes\";\nimport { getAngle } from \"../utils\";\n\nimport { toAxis } from \"./InputType\";\nimport { PanInput, PanInputOption } from \"./PanInput\";\n\n/**\n * @class eg.Axes.RotatePanInput\n * @classdesc A module that passes the angle moved by touch to Axes and uses one axis of rotation.<br>[Details](https://github.com/naver/egjs-axes/wiki/RotatePanInput)\n * @ko 터치에 의해 움직인 각도를 Axes 에 전달하며 1개의 회전축만 사용한다.<br>[상세내용](https://github.com/naver/egjs-axes/wiki/RotatePanInput-%7C-%ED%95%9C%EA%B5%AD%EC%96%B4)\n *\n * @example\n * const input = new eg.Axes.RotatePanInput(\"#area\");\n *\n * var axes = new eg.Axes({\n *\t// property name('angle') could be anything you want (eg. x, y, z...)\n * \tangle: {\n * \t\trange: [-180, 180] // from -180deg to 180deg\n * \t}\n * });\n *\n * axes.connect(\"angle\", input)\n *\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.RotatePanInput module <ko>eg.Axes.RotatePanInput 모듈을 사용할 엘리먼트</ko>\n * @param {PanInputOption} [options] The option object of the eg.Axes.PanInput module<ko>eg.Axes.PanInput 모듈의 옵션 객체</ko>\n * @extends eg.Axes.PanInput\n */\nexport class RotatePanInput extends PanInput {\n  private _rotateOrigin: number[];\n  private _prevAngle: number;\n  private _prevQuadrant: number = null;\n  private _lastDiff = 0;\n  private _coefficientForDistanceToAngle: number;\n\n  public constructor(el: string | HTMLElement, options?: PanInputOption) {\n    super(el, options);\n  }\n\n  public mapAxes(axes: string[]) {\n    this._direction = Axes.DIRECTION_ALL;\n    this.axes = axes;\n  }\n\n  public onPanstart(event: MouseEvent) {\n    this._activeInput.onEventStart(event);\n    if (!this.isEnabled) {\n      return;\n    }\n\n    const rect = this.element.getBoundingClientRect();\n    const panEvent = this._activeInput.extendEvent(event);\n\n    this._observer.hold(this, panEvent);\n    this._panFlag = true;\n    /**\n     * Responsive\n     */\n    // TODO: how to do if element is ellipse not circle.\n    this._coefficientForDistanceToAngle = 360 / (rect.width * Math.PI); // from 2*pi*r * x / 360\n    // TODO: provide a way to set origin like https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n    this._rotateOrigin = [\n      rect.left + (rect.width - 1) / 2,\n      rect.top + (rect.height - 1) / 2,\n    ];\n\n    // init angle.\n    this._prevAngle = null;\n\n    this._triggerChange(panEvent);\n    this._activeInput.prevEvent = panEvent;\n  }\n\n  public onPanmove(event: MouseEvent) {\n    this._activeInput.onEventMove(event);\n    if (!this._panFlag || !this.isEnabled) {\n      return;\n    }\n\n    const panEvent = this._activeInput.extendEvent(event);\n\n    if (panEvent.srcEvent.cancelable !== false) {\n      panEvent.srcEvent.preventDefault();\n    }\n    panEvent.srcEvent.stopPropagation();\n    this._triggerChange(panEvent);\n    this._activeInput.prevEvent = panEvent;\n  }\n\n  public onPanend(event: MouseEvent) {\n    this._activeInput.onEventEnd(event);\n    if (!this._panFlag || !this.isEnabled) {\n      return;\n    }\n    const prevEvent = this._activeInput.prevEvent;\n    this._triggerChange(prevEvent);\n    const vx = prevEvent.velocityX;\n    const vy = prevEvent.velocityY;\n    const velocity =\n      Math.sqrt(vx * vx + vy * vy) * (this._lastDiff > 0 ? -1 : 1); // clockwise\n    this._observer.release(this, prevEvent, [\n      velocity * this._coefficientForDistanceToAngle,\n    ]);\n    this._panFlag = false;\n  }\n\n  private _triggerChange(event: ExtendedEvent) {\n    const { x, y } = this._getPosFromOrigin(event.center.x, event.center.y);\n    const angle = getAngle(x, y);\n    const quadrant = this._getQuadrant(event.center.x, event.center.y);\n    const diff = this._getDifference(\n      this._prevAngle,\n      angle,\n      this._prevQuadrant,\n      quadrant\n    );\n\n    this._prevAngle = angle;\n    this._prevQuadrant = quadrant;\n\n    if (diff === 0) {\n      return;\n    }\n\n    this._lastDiff = diff;\n    this._observer.change(this, event, toAxis(this.axes, [-diff])); // minus for clockwise\n  }\n\n  private _getDifference(\n    prevAngle: number,\n    angle: number,\n    prevQuadrant: number,\n    quadrant: number\n  ) {\n    let diff: number;\n\n    if (prevAngle === null) {\n      diff = 0;\n    } else if (prevQuadrant === 1 && quadrant === 4) {\n      diff = -prevAngle - (360 - angle);\n    } else if (prevQuadrant === 4 && quadrant === 1) {\n      diff = 360 - prevAngle + angle;\n    } else {\n      diff = angle - prevAngle;\n    }\n\n    return diff;\n  }\n\n  private _getPosFromOrigin(posX: number, posY: number) {\n    return {\n      x: posX - this._rotateOrigin[0],\n      y: this._rotateOrigin[1] - posY,\n    };\n  }\n\n  /**\n   * Quadrant\n   *       y(+)\n   *       |\n   *   2   |    1\n   * --------------->x(+)\n   *   3   |    4\n   *       |\n   */\n  private _getQuadrant(posX: number, posY: number) {\n    const { x, y } = this._getPosFromOrigin(posX, posY);\n    let q = 0;\n\n    if (x >= 0 && y >= 0) {\n      q = 1;\n    } else if (x < 0 && y >= 0) {\n      q = 2;\n    } else if (x < 0 && y < 0) {\n      q = 3;\n    } else if (x >= 0 && y < 0) {\n      q = 4;\n    }\n    return q;\n  }\n}\n","import { $, setCssProps } from \"../utils\";\nimport { ActiveInput, InputEventType } from \"../types\";\nimport { PREVENT_SCROLL_CSSPROPS } from \"../const\";\n\nimport {\n  toAxis,\n  convertInputType,\n  IInputType,\n  IInputTypeObserver,\n} from \"./InputType\";\n\nexport interface PinchInputOption {\n  scale?: number;\n  threshold?: number;\n  inputType?: string[];\n}\n\n/**\n * @typedef {Object} PinchInputOption The option object of the eg.Axes.PinchInput module\n * @ko eg.Axes.PinchInput 모듈의 옵션 객체\n * @property {Number} [scale=1] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @property {Number} [threshold=0] Minimal scale before recognizing <ko>사용자의 Pinch 동작을 인식하기 위해산 최소한의 배율</ko>\n **/\n\n/**\n * @class eg.Axes.PinchInput\n * @classdesc A module that passes the amount of change to eg.Axes when two pointers are moving toward (zoom-in) or away from each other (zoom-out). use one axis.\n * @ko 2개의 pointer를 이용하여 zoom-in하거나 zoom-out 하는 동작의 변화량을 eg.Axes에 전달하는 모듈. 한 개 의 축을 사용한다.\n * @example\n * const pinch = new eg.Axes.PinchInput(\"#area\", {\n * \t\tscale: 1\n * });\n *\n * // Connect 'something' axis when two pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * axes.connect(\"something\", pinch);\n *\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.PinchInput module <ko>eg.Axes.PinchInput 모듈을 사용할 엘리먼트</ko>\n * @param {PinchInputOption} [options] The option object of the eg.Axes.PinchInput module<ko>eg.Axes.PinchInput 모듈의 옵션 객체</ko>\n */\nexport class PinchInput implements IInputType {\n  public options: PinchInputOption;\n  public axes: string[] = [];\n  public element: HTMLElement = null;\n  private _observer: IInputTypeObserver;\n  private _pinchFlag = false;\n  private _enabled = false;\n  private _originalCssProps: { [key: string]: string };\n  private _activeInput: ActiveInput = null;\n  private _baseValue: number;\n\n  public constructor(el: string | HTMLElement, options?: PinchInputOption) {\n    this.element = $(el);\n    this.options = {\n      scale: 1,\n      threshold: 0,\n      inputType: [\"touch\", \"pointer\"],\n      ...options,\n    };\n    this._onPinchStart = this._onPinchStart.bind(this);\n    this._onPinchMove = this._onPinchMove.bind(this);\n    this._onPinchEnd = this._onPinchEnd.bind(this);\n  }\n\n  public mapAxes(axes: string[]) {\n    this.axes = axes;\n  }\n\n  public connect(observer: IInputTypeObserver): IInputType {\n    if (this._activeInput) {\n      this._detachEvent();\n    }\n    this._attachEvent(observer);\n    this._originalCssProps = setCssProps(this.element);\n    return this;\n  }\n\n  public disconnect() {\n    this._detachEvent();\n    if (this._originalCssProps !== PREVENT_SCROLL_CSSPROPS) {\n      setCssProps(this.element, this._originalCssProps);\n    }\n    return this;\n  }\n\n  /**\n   * Destroys elements, properties, and events used in a module.\n   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n   * @method eg.Axes.PinchInput#destroy\n   */\n  public destroy() {\n    this.disconnect();\n    this.element = null;\n  }\n\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @method eg.Axes.PinchInput#enable\n   * @return {eg.Axes.PinchInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enable() {\n    this._enabled = true;\n    return this;\n  }\n\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @method eg.Axes.PinchInput#disable\n   * @return {eg.Axes.PinchInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disable() {\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @method eg.Axes.PinchInput#isEnable\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  private _onPinchStart(event: InputEventType) {\n    this._activeInput.onEventStart(event);\n    if (!this._enabled || this._activeInput.getTouches(event) !== 2) {\n      return;\n    }\n\n    this._baseValue = this._observer.get(this)[this.axes[0]];\n    this._observer.hold(this, event);\n    this._pinchFlag = true;\n    const pinchEvent = this._activeInput.extendEvent(event);\n    this._activeInput.prevEvent = pinchEvent;\n  }\n\n  private _onPinchMove(event: InputEventType) {\n    this._activeInput.onEventMove(event);\n    if (\n      !this._pinchFlag ||\n      !this._enabled ||\n      this._activeInput.getTouches(event) !== 2\n    ) {\n      return;\n    }\n\n    const pinchEvent = this._activeInput.extendEvent(event);\n    const offset = this._getOffset(\n      pinchEvent.scale,\n      this._activeInput.prevEvent.scale\n    );\n    this._observer.change(this, event, toAxis(this.axes, [offset]));\n    this._activeInput.prevEvent = pinchEvent;\n  }\n\n  private _onPinchEnd(event: InputEventType) {\n    this._activeInput.onEventEnd(event);\n    if (\n      !this._pinchFlag ||\n      !this._enabled ||\n      this._activeInput.getTouches(event) > 2\n    ) {\n      return;\n    }\n\n    this._observer.release(this, event, [0], 0);\n    this._baseValue = null;\n    this._pinchFlag = false;\n    this._activeInput.prevEvent = null;\n  }\n\n  private _attachEvent(observer: IInputTypeObserver) {\n    const activeInput = convertInputType(this.options.inputType);\n    this._observer = observer;\n    this._enabled = true;\n    this._activeInput = activeInput;\n    activeInput.start.forEach((event) => {\n      this.element.addEventListener(event, this._onPinchStart, false);\n    });\n    activeInput.move.forEach((event) => {\n      this.element.addEventListener(event, this._onPinchMove, false);\n    });\n    activeInput.end.forEach((event) => {\n      this.element.addEventListener(event, this._onPinchEnd, false);\n    });\n  }\n\n  private _detachEvent() {\n    const activeInput = this._activeInput;\n    activeInput.start.forEach((event) => {\n      this.element.removeEventListener(event, this._onPinchStart, false);\n    });\n    activeInput.move.forEach((event) => {\n      this.element.removeEventListener(event, this._onPinchMove, false);\n    });\n    activeInput.end.forEach((event) => {\n      this.element.removeEventListener(event, this._onPinchEnd, false);\n    });\n    this._enabled = false;\n    this._observer = null;\n  }\n\n  private _getOffset(pinchScale: number, prev: number = 1): number {\n    return this._baseValue * (pinchScale - prev) * this.options.scale;\n  }\n}\n","import { $ } from \"../utils\";\n\nimport { toAxis, IInputType, IInputTypeObserver } from \"./InputType\";\n\nexport interface WheelInputOption {\n  scale?: number;\n  releaseDelay?: number;\n  useNormalized?: boolean;\n}\n\n/**\n * @typedef {Object} WheelInputOption The option object of the eg.Axes.WheelInput module\n * @ko eg.Axes.WheelInput 모듈의 옵션 객체\n * @property {Number} [scale=1] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @property {Number} [releaseDelay=300] Millisecond that trigger release event after last input<ko>마지막 입력 이후 release 이벤트가 트리거되기까지의 밀리초</ko>\n **/\n\n/**\n * @class eg.Axes.WheelInput\n * @classdesc A module that passes the amount of change to eg.Axes when the mouse wheel is moved. use one axis.\n * @ko 마우스 휠이 움직일때의 변화량을 eg.Axes에 전달하는 모듈. 한 개 의 축을 사용한다.\n *\n * @example\n * const wheel = new eg.Axes.WheelInput(\"#area\", {\n * \t\tscale: 1\n * });\n *\n * // Connect 'something' axis when the mousewheel is moved.\n * axes.connect(\"something\", wheel);\n *\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.WheelInput module <ko>eg.Axes.WheelInput 모듈을 사용할 엘리먼트</ko>\n * @param {WheelInputOption} [options] The option object of the eg.Axes.WheelInput module<ko>eg.Axes.WheelInput 모듈의 옵션 객체</ko>\n */\nexport class WheelInput implements IInputType {\n  public options: WheelInputOption;\n  public axes: string[] = [];\n  public element: HTMLElement = null;\n  private _observer: IInputTypeObserver;\n  private _enabled = false;\n  private _holding = false;\n  private _timer: NodeJS.Timeout = null;\n\n  public constructor(el, options?: WheelInputOption) {\n    this.element = $(el);\n    this.options = {\n      ...{\n        scale: 1,\n        releaseDelay: 300,\n        useNormalized: true,\n      },\n      ...options,\n    };\n    this._onWheel = this._onWheel.bind(this);\n  }\n\n  public mapAxes(axes: string[]) {\n    this.axes = axes;\n  }\n\n  public connect(observer: IInputTypeObserver): IInputType {\n    this._detachEvent();\n    this._attachEvent(observer);\n    return this;\n  }\n\n  public disconnect() {\n    this._detachEvent();\n    return this;\n  }\n\n  /**\n   * Destroys elements, properties, and events used in a module.\n   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n   * @method eg.Axes.WheelInput#destroy\n   */\n  public destroy() {\n    this.disconnect();\n    this.element = null;\n  }\n\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @method eg.Axes.WheelInput#enable\n   * @return {eg.Axes.WheelInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enable() {\n    this._enabled = true;\n    return this;\n  }\n\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @method eg.Axes.WheelInput#disable\n   * @return {eg.Axes.WheelInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disable() {\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @method eg.Axes.WheelInput#isEnable\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  private _onWheel(event: WheelEvent) {\n    if (!this._enabled) {\n      return;\n    }\n    event.preventDefault();\n\n    if (event.deltaY === 0) {\n      return;\n    }\n\n    if (!this._holding) {\n      this._observer.hold(this, event);\n      this._holding = true;\n    }\n    const offset =\n      (event.deltaY > 0 ? -1 : 1) *\n      this.options.scale *\n      (this.options.useNormalized ? 1 : Math.abs(event.deltaY));\n    this._observer.change(this, event, toAxis(this.axes, [offset]), true);\n    clearTimeout(this._timer);\n\n    this._timer = setTimeout(() => {\n      if (this._holding) {\n        this._holding = false;\n        this._observer.release(this, event, [0]);\n      }\n    }, this.options.releaseDelay);\n  }\n\n  private _attachEvent(observer: IInputTypeObserver) {\n    this._observer = observer;\n    this.element.addEventListener(\"wheel\", this._onWheel);\n    this._enabled = true;\n  }\n\n  private _detachEvent() {\n    this.element.removeEventListener(\"wheel\", this._onWheel);\n    this._enabled = false;\n    this._observer = null;\n\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  }\n}\n","import { $ } from \"../utils\";\n\nimport { toAxis, IInputType, IInputTypeObserver } from \"./InputType\";\n\nexport const KEY_LEFT_ARROW = 37;\nexport const KEY_A = 65;\nexport const KEY_UP_ARROW = 38;\nexport const KEY_W = 87;\nexport const KEY_RIGHT_ARROW = 39;\nexport const KEY_D = 68;\nexport const KEY_DOWN_ARROW = 40;\nexport const KEY_S = 83;\n\n/* eslint-disable */\nconst DIRECTION_REVERSE = -1;\nconst DIRECTION_FORWARD = 1;\nconst DIRECTION_HORIZONTAL = -1;\nconst DIRECTION_VERTICAL = 1;\nconst DELAY = 80;\n/* eslint-enable */\n\nexport interface MoveKeyInputOption {\n  scale?: number[];\n}\n\n/**\n * @typedef {Object} MoveKeyInputOption The option object of the eg.Axes.MoveKeyInput module\n * @ko eg.Axes.MoveKeyInput 모듈의 옵션 객체\n * @property {Array<Number>} [scale] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>\n * @property {Number} [scale[0]=1] Coordinate scale for the first axis<ko>첫번째 축의 배율</ko>\n * @property {Number} [scale[1]=1] Coordinate scale for the decond axis<ko>두번째 축의 배율</ko>\n **/\n\n/**\n * @class eg.Axes.MoveKeyInput\n * @classdesc A module that passes the amount of change to eg.Axes when the move key stroke is occured. use two axis.\n * @ko 이동키 입력이 발생했을 때의 변화량을 eg.Axes에 전달하는 모듈. 두 개 의 축을 사용한다.\n *\n * @example\n * const moveKey = new eg.Axes.MoveKeyInput(\"#area\", {\n * \t\tscale: [1, 1]\n * });\n *\n * // Connect 'x', 'y' axes when the moveKey is pressed.\n * axes.connect([\"x\", \"y\"], moveKey);\n *\n * @param {HTMLElement|String|jQuery} element An element to use the eg.Axes.MoveKeyInput module <ko>eg.Axes.MoveKeyInput 모듈을 사용할 엘리먼트</ko>\n * @param {MoveKeyInputOption} [options] The option object of the eg.Axes.MoveKeyInput module<ko>eg.Axes.MoveKeyInput 모듈의 옵션 객체</ko>\n */\nexport class MoveKeyInput implements IInputType {\n  public options: MoveKeyInputOption;\n  public axes: string[] = [];\n  public element: HTMLElement = null;\n  private _observer: IInputTypeObserver;\n  private _enabled = false;\n  private _holding = false;\n  private _timer: NodeJS.Timeout = null;\n\n  public constructor(el, options?: MoveKeyInputOption) {\n    this.element = $(el);\n    this.options = {\n      ...{\n        scale: [1, 1],\n      },\n      ...options,\n    };\n    this._onKeydown = this._onKeydown.bind(this);\n    this._onKeyup = this._onKeyup.bind(this);\n  }\n\n  public mapAxes(axes: string[]) {\n    this.axes = axes;\n  }\n\n  public connect(observer: IInputTypeObserver): IInputType {\n    this._detachEvent();\n\n    // add tabindex=\"0\" to the container for making it focusable\n    if (this.element.getAttribute(\"tabindex\") !== \"0\") {\n      this.element.setAttribute(\"tabindex\", \"0\");\n    }\n\n    this._attachEvent(observer);\n    return this;\n  }\n\n  public disconnect() {\n    this._detachEvent();\n    return this;\n  }\n\n  /**\n   * Destroys elements, properties, and events used in a module.\n   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.\n   * @method eg.Axes.MoveKeyInput#destroy\n   */\n  public destroy() {\n    this.disconnect();\n    this.element = null;\n  }\n\n  /**\n   * Enables input devices\n   * @ko 입력 장치를 사용할 수 있게 한다\n   * @method eg.Axes.MoveKeyInput#enable\n   * @return {eg.Axes.MoveKeyInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enable() {\n    this._enabled = true;\n    return this;\n  }\n\n  /**\n   * Disables input devices\n   * @ko 입력 장치를 사용할 수 없게 한다.\n   * @method eg.Axes.MoveKeyInput#disable\n   * @return {eg.Axes.MoveKeyInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disable() {\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Returns whether to use an input device\n   * @ko 입력 장치를 사용 여부를 반환한다.\n   * @method eg.Axes.MoveKeyInput#isEnable\n   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>\n   */\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  private _onKeydown(event: KeyboardEvent) {\n    if (!this._enabled) {\n      return;\n    }\n\n    let isMoveKey = true;\n    let direction = DIRECTION_FORWARD;\n    let move = DIRECTION_HORIZONTAL;\n\n    switch (event.keyCode) {\n      case KEY_LEFT_ARROW:\n      case KEY_A:\n        direction = DIRECTION_REVERSE;\n        break;\n      case KEY_RIGHT_ARROW:\n      case KEY_D:\n        break;\n      case KEY_DOWN_ARROW:\n      case KEY_S:\n        direction = DIRECTION_REVERSE;\n        move = DIRECTION_VERTICAL;\n        break;\n      case KEY_UP_ARROW:\n      case KEY_W:\n        move = DIRECTION_VERTICAL;\n        break;\n      default:\n        isMoveKey = false;\n    }\n    if (\n      (move === DIRECTION_HORIZONTAL && !this.axes[0]) ||\n      (move === DIRECTION_VERTICAL && !this.axes[1])\n    ) {\n      isMoveKey = false;\n    }\n    if (!isMoveKey) {\n      return;\n    }\n    event.preventDefault();\n    const offsets =\n      move === DIRECTION_HORIZONTAL\n        ? [+this.options.scale[0] * direction, 0]\n        : [0, +this.options.scale[1] * direction];\n\n    if (!this._holding) {\n      this._observer.hold(this, event);\n      this._holding = true;\n    }\n    clearTimeout(this._timer);\n    this._observer.change(this, event, toAxis(this.axes, offsets));\n  }\n\n  private _onKeyup(event: KeyboardEvent) {\n    if (!this._holding) {\n      return;\n    }\n    clearTimeout(this._timer);\n    this._timer = setTimeout(() => {\n      this._observer.release(this, event, [0, 0]);\n      this._holding = false;\n    }, DELAY);\n  }\n\n  private _attachEvent(observer: IInputTypeObserver) {\n    this._observer = observer;\n    this.element.addEventListener(\"keydown\", this._onKeydown, false);\n    this.element.addEventListener(\"keypress\", this._onKeydown, false);\n    this.element.addEventListener(\"keyup\", this._onKeyup, false);\n    this._enabled = true;\n  }\n\n  private _detachEvent() {\n    this.element.removeEventListener(\"keydown\", this._onKeydown, false);\n    this.element.removeEventListener(\"keypress\", this._onKeydown, false);\n    this.element.removeEventListener(\"keyup\", this._onKeyup, false);\n    this._enabled = false;\n    this._observer = null;\n  }\n}\n","import Axes from \"./Axes\";\nimport { PanInput } from \"./inputType/PanInput\";\nimport { RotatePanInput } from \"./inputType/RotatePanInput\";\nimport { PinchInput } from \"./inputType/PinchInput\";\nimport { WheelInput } from \"./inputType/WheelInput\";\nimport { MoveKeyInput } from \"./inputType/MoveKeyInput\";\n\nAxes.PanInput = PanInput;\nAxes.RotatePanInput = RotatePanInput;\nAxes.PinchInput = PinchInput;\nAxes.WheelInput = WheelInput;\nAxes.MoveKeyInput = MoveKeyInput;\n\nexport default Axes;\n"],"names":["getInsidePosition","destPos","range","circular","bounce","toDestPos","targetRange","Math","max","min","isOutside","pos","isCircularable","getCirculatedPos","toPos","length","win","window","navigator","userAgent","toArray","nodes","el","i","len","push","keyInfo_1","oldraf_1","IS_IOS_SAFARI","browser","name","TRANSFORM","document","bodyStyle","head","getElementsByTagName","style","target","PREVENT_SCROLL_CSSPROPS","$","param","multi","dummy","match","createElement","innerHTML","childNodes","querySelectorAll","undefined","nodeName","nodeType","jQuery","constructor","prototype","jquery","get","Array","isArray","map","v","raf","requestAnimationFrame","webkitRequestAnimationFrame","caf","cancelAnimationFrame","webkitCancelAnimationFrame","callback","key","timestamp","setTimeout","performance","now","Date","getTime","clearTimeout","obj","tranformed","k","filter","filtered","every","equal","base","roundNumber","num","roundUnit","roundNumFunc","getRoundFunc","roundNumbers","value","getDecimalPlace","val","isFinite","indexOf","p","e","round","getAngle","posX","posY","atan2","PI","setCssProps","element","originalCssProps","newCssProps_1","oldCssProps","Object","keys","forEach","prop","clamp","toAxis","source","offset","reduce","acc","convertInputType","inputType","hasTouch","hasMouse","hasPointer","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","PointerEventInput","TouchMouseEventInput","TouchEventInput","MouseEventInput","useDirection","checkType","direction","userDirection","pow","n","_a","options","itm","em","axm","_options","animationEnd","this","bind","depaPos","wishDuration","durations_1","duration","distance","abs","deceleration","_this","sqrt","Infinity","minimumDuration","maximumDuration","velocity","totalVelocity","total","displacement","threshold","initSlope","easing","axes","option","orgPos_1","_animateParam","opt","triggerChange","_raf","triggerAnimationEnd","event","input","inputEvent","animateTo","getDuration","beforeParam","getEventInfo","circularTargets","setTo","setInterrupt","restore","finish","isTrusted","triggerFinish","userWish","_createAnimationParam","retTrigger","triggerAnimationStart","getUserControl","console","warn","_animateLoop","delta","getDelta","stopAnimation","orgPos","movedPos","diffTime","currentPos","ratio","animateParam","startTime","restart","_initialEasingPer","_prevEasingPer","_durationOffset","done","complete","prevPos_1","directions_1","originalIntendedPos_1","loop_1","easingPer","rangeOffset","nextPos","circulatedPos","isCanceled","_getFinalPos","originalIntendedPos","_getRoundUnit","minRoundUnit","getAxisOptions","_axes","roundPos","_getRoundPos","trigger","ComponentEvent","roundDepa","_createUserControll","__assign","bounceRatio","_getBounceRatio","isAccurate","holding","am","eventInfo","moveTo","set","result","off","userControl","userDuration","interruptable","_prevented","prevented","_axis","_complementOptions","_pos","fullDepaPos","axisOptions","axis","axisOption","test","SUPPORT_POINTER","SUPPORT_MSPOINTER","prevEvent","center","_getCenter","movement","_getMovement","x","y","scale","_getScale","angle","deltaX","deltaY","offsetX","offsetY","srcEvent","velocityX","timeStamp","velocityY","preventSystemEvent","start","end","clientX","clientY","__extends","extendEvent","prev","pageX","pageY","EventInput","_firstTouch","touches","_getDistance","identifier","_updatePointerEvent","_removePointerEvent","_recentInputs","_firstInputs","pointerId","addFlag","TouchEvent","id","nextSpot","prevSpot","_itm","_em","_axm","_am","changeOption","isInterrupted","_isStopped","_moveDistance","triggerHold","_isOutside","useDuration","isInterrupting","_atOutside","inputDuration","isEqual","getDisplacement","triggerRelease","tn","tx","out","interpolate","startPos","_super","InterruptManager","AxisManager","EventManager","AnimationManager","io","InputObserver","setAnimationManager","mapped","split","concat","_inputs","disconnect","mapAxes","connect","index","splice","setBy","updateAnimation","destroy","Axes","Component","thresholdAngle","iOSEdgeSwipeThreshold","releaseOnScroll","_onPanstart","_onPanmove","_onPanend","useHorizontal","useVertical","_direction","observer","_activeInput","_detachEvent","_attachEvent","_originalCssProps","_enabled","panEvent","edgeThreshold","onEventStart","getTouches","_panFlag","cancelable","_observer","hold","_atRightEdge","innerWidth","onEventMove","toAngle","getDirectionByAngle","_rightEdgeTimer","_getOffset","prevent","some","preventDefault","stopPropagation","change","onEventEnd","release","activeInput","addEventListener","move","removeEventListener","properties","DIRECTION_ALL","rect","isEnabled","getBoundingClientRect","_coefficientForDistanceToAngle","width","_rotateOrigin","left","top","height","_prevAngle","_triggerChange","vx","vy","_lastDiff","_getPosFromOrigin","quadrant","_getQuadrant","diff","_getDifference","_prevQuadrant","prevAngle","prevQuadrant","q","PanInput","_onPinchStart","_onPinchMove","_onPinchEnd","pinchEvent","_baseValue","_pinchFlag","pinchScale","releaseDelay","useNormalized","_onWheel","_holding","_timer","_onKeydown","_onKeyup","getAttribute","setAttribute","offsets","isMoveKey","keyCode","RotatePanInput","PinchInput","WheelInput","MoveKeyInput"],"mappings":"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"}